package proye1_compi;
import java_cup.runtime.*;
import java.util.HashMap; 
import java.util.List;
import java.util.ArrayList;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

parser code {:
    // Connect this parser to a scanner!
    Lexer lex;
    HashMap<String, ArrayList<String>> scopePrograma = new HashMap<String, ArrayList<String>>();
    String currentHash = "a";
    String globalHash = "SCOPE GLOBAL";

    @SuppressWarnings("deprecation")
    public Parser(Lexer lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }

    public boolean existeVar(String ID, String tipo) {
        if (currentHash.equals("a")) {return false;}

        ArrayList<String> ts = scopePrograma.get(currentHash);

        String comparado = "Instancia loc: " + ID.toString() + ":" + tipo;

        for (String variable : ts) {
            if (variable.equals(comparado)) {return true;}
        }

        return false;
    }

    public static void WriteToFile(String filename, String content) throws IOException {
        FileWriter writer = new FileWriter(filename);
        // Escribir contenido en el archivo
        writer.write(content);
        // Es importante cerrar el escritor después de haber terminado de escribir
        writer.close();
        System.out.println("El archivo se ha escrito correctamente.\n");
    }    

    public boolean existeVarNoT(String ID) {
        if (currentHash.equals("a")) {return false;}
        ArrayList<String> ts = scopePrograma.get(currentHash);
        ArrayList<String> ts2 = scopePrograma.get(globalHash);
        
        for (String variable : ts) {
            String[] elementosVar = variable.split(":");
            
            if (elementosVar[1].trim().equals(ID)) {return true;}
        }
        for (String variable2 : ts2) {
            String[] elementosVar2 = variable2.split(":");
            
            if (elementosVar2[1].trim().equals(ID)) {return true;}
        }

        return false;
    }

    public String getTipo(String ID) {
        if (!currentHash.equals("a")) {
            ArrayList<String> ts = scopePrograma.get(currentHash);
            
            for (String variable : ts) {
            String[] elementosVar = variable.split(":");
            if (elementosVar[1].trim().equals(ID)) {return elementosVar[2];}
            }
        }

        ArrayList<String> ts2 = scopePrograma.get(globalHash);

        for (String variable : ts2) {
            String[] elementosVar = variable.split(":");
            if (elementosVar[1].trim().equals(ID)) {return elementosVar[2];}
        }

        return "null";
    }

    public String getTipoFunc(String ID) {
        for (String key : scopePrograma.keySet()) {
            
            ArrayList<String> value = scopePrograma.get(key);
            for (String elemento : value) {
                String[] ts = elemento.split(":");
                if (ID.equals(key)) {
                    return ts[2];
                }
            }
        } 

        return "null";
    }

    public boolean existeVarGlob(String ID, String tipo) {
        ArrayList<String> ts = scopePrograma.get(globalHash);
        String comparado = "Instancia GLOB: " + ID.toString() + ":" + tipo;
        
        for (String variable : ts) {
            if (variable.equals(comparado)) {return true;}
        }

        return false;
    }

    public boolean validarReturn(String tipo) {
        if (currentHash.equals("a")) {return false;}
        ArrayList<String> ts = scopePrograma.get(currentHash);
        
        String[] elementos = ts.get(0).split(":");
        String elemento = elementos[2];
        if (!tipo.equals(elemento)) {return false;}

        return true;
    }

    public boolean existeFun(String ID, String tipo) {
        for (String key : scopePrograma.keySet()) {
            ArrayList<String> value = scopePrograma.get(key);
            for (String elemento : value) {
                String[] ts = elemento.split(":");
                if (ts.length >= 3 && ts[1].equals("func") && ts[2].equals(tipo) && ID.equals(key)) {
                    return true;
                }
            }
        } 

        return false;
    }

    public void imprimirscopePrograma () {
        System.out.println("\nTABLA DE SIMBOLOS");
        for (String key: scopePrograma.keySet()) {
            System.out.println("\n" + key);
            System.out.println("Valores: ");
            for (String item : scopePrograma.get(key)) {
                System.out.println(item);
            }
            System.out.println("");
        }
    }

    public boolean existeArrGlob(String ID, String tipo) {
        ArrayList<String> ts = scopePrograma.get(globalHash);
        String comparado = "Instancia GLOB ARR: " + ID.toString() + ":" + tipo;
        
        for (String variable : ts) {
            if (variable.equals(comparado)) {return true;}
        }

        return false;
    }

    public boolean todosIguales(ArrayList<String> lista) {
        String primerElemento = lista.get(0);
        for (int i = 1; i < lista.size(); i++) {
            if (!lista.get(i).equals(primerElemento)) {
                return false; 
            }
        }

        return true; 
    }

    public boolean existeArr(String ID, String tipo) {
        if (currentHash.equals("a")) {return false;}
        ArrayList<String> ts = scopePrograma.get(currentHash);
        String comparado = "Instancia LOC ARR: " + ID.toString() + ":" + tipo;

        for (String variable : ts) {

            if (variable.equals(comparado)) {return true;}
        }

        return false;
    }

    public int countParam (String nombreFunc) {
        if (scopePrograma.get(nombreFunc) == null) {return -1;}

        ArrayList<String> currentFunc = scopePrograma.get(nombreFunc);
        int cantParam = 0;

        for (String elem : currentFunc) {
            String[] expresion = elem.split(":");
            String lexema = expresion[0].trim();
            
            
            if(lexema.equals("Instancia PARAM") ){ cantParam++;}
        }
        return cantParam;
    }

    public void writeAsignArr(String id) {
        String texto = "[";
        
        for(int i = 0; i < elementosArray.size(); i++) {
            Integer y = elementosArray.size();
            Integer x = currentTemp - y + 1 + i;
            texto = texto + "t" + x;
            
            if (!y.equals(i + 1)) {texto = texto + ", ";}
        }
        texto = texto + "]";
        cod3D.append("\n" + id + "=" + texto);
    }

    //recuperacion de errores de sintaxis
    public void syntax_error(Symbol s) {
        System.out.println("!!Error de Sintaxis en : " +  s.value + " linea: " +  (s.left+1) +  " columna: " +  (s.right+1));
    }

    //manejo de errores fatales
    public void unrecovered_syntax_error(Symbol s) {
        System.out.println("!!Error fatal en : " +  s.value + " linea: " +  (s.left+1) +  " columna: " +  (s.right+1));
    } 

    StringBuffer cod3D = new StringBuffer();
    Integer currentTemp = 0;
    Integer currentFloat = 0;
    Integer stackPointer = 0;
    Integer cantParams = 0;
    Integer currentParam = 0;
    Integer currentStruc = 0;
    Integer casesCont = 0;
    Integer casesContRes = 0;
    Integer currentReturns = 0;
    boolean breakSwitch = false;
    String idSwitch;
    ArrayList<String> elementosArray = new ArrayList<>();
:}

/* define how to connect to the scanner! */
//init with {: s.init(); :};
//scan with {: return s.next_token(); :};
init with {::};
scan with {:return lex.next_token();:};


/* Terminales (tokens returned by the scanner). */
terminal            IDENTIFIER, SEMI, PLUS, MINUS, DMINUS, DPLUS, MINUSW, TIMES, UMINUS, PRODUCT, DIVISION, POWER, MODULUS, LPAREN, RPAREN, INTEGER_LITERAL;
terminal Integer    NUMBER;        // our scanner provides numbers as integers
terminal            DELIMETERBLOCK, ASIGNINTSARRAY, ASIGNCHARSARRAY, CHARSTR, INT, CHAR, FLOAT, BOOL, STRINGT, FUNC, MAIN, PARAM, COMA, STRING_LITERAL, EQEQ, BREAK, BOOLEAN, ABSTRACT, EQ, DOT;
terminal            DIFF, NEGATION, GRATHER, GRATHERT, LOWER, LOWERT, COMPARATION, AND, OR, SEP;
terminal            FLOATNUM;
terminal            TRUE, FALSE;
terminal            IF, ELSE, WHILE, FOR, IN, RANGE, SWITCH, CASE, ARRAY;
terminal            LOC, GLOB, BRAKE, DEFAULT, RETURN, PRINT, INPUT;
terminal            PARENTS, PARENTC, SQUARES, SQUAREC;
terminal            ENDEXPR;

/* No terminales */
non terminal            expr_list;
non terminal            Integer expr;// used to store evaluated subexpressions
non terminal            SI, varIns, varAsig, BLOCK, compAritOp, factor, term, funcStruc, mainStruc, types, printStruc;
non terminal            ifStruc, ifElseStruc, whileStruc, arrayIns, arrayAsig, arrayInsAsign, elementos, switchStruc, caseStruc, forStruc, numbers;
non terminal            caseMid, caseStrucBegin, defaultStruc, switchBegin, forStrucBegin3, forStrucBegin2, forStrucBegin, whileBegin, elseStruc, ifStrucComplete, returnStruc, inputStruc, mainInitial, funInitial, exprP, exprLog, exprUni, opRel, opLog, arrayElement, paramStruc, paramList, paramFunc, funcInvo, GEN, arrayInsGl, varInsGl, varInsAsig, varInsAsigGl, arrayInsAsignGl;

/* Orden de precedencia */
precedence left PLUS, MINUSW;
precedence left PRODUCT;
precedence left DIVISION;

/* The grammar rules */    

start with SI;

SI ::= {: scopePrograma.put(globalHash, new ArrayList<String>()); :} 
    GEN {: System.out.println(cod3D.toString()); WriteToFile("3Dcode.txt", cod3D.toString()); :};//{: imprimirscopePrograma(); :}

GEN ::= funcStruc GEN | mainStruc GEN | arrayInsGl ENDEXPR GEN | varInsGl ENDEXPR GEN | varInsAsigGl 
    | varInsAsigGl GEN | funcStruc | mainStruc | arrayInsGl ENDEXPR | varInsGl ENDEXPR | error | error GEN
    | arrayInsAsignGl GEN | arrayInsAsignGl;  

//Los distintos tipos que pueden tener una funcion o variable

//Bloque que se usa para el codigo siga un rumbo, vease como la lista de posibles expresiones
BLOCK ::= BLOCK exprP ENDEXPR
        | BLOCK varAsig 
        | BLOCK arrayInsGl ENDEXPR
        | BLOCK varInsGl ENDEXPR
        | BLOCK varInsAsigGl
        | BLOCK arrayInsAsignGl
        | BLOCK mainStruc
        | BLOCK funcStruc 
        | BLOCK varIns ENDEXPR
        | BLOCK ifStrucComplete 
        | BLOCK ifElseStruc 
        | BLOCK whileStruc 
        | BLOCK switchStruc 
        | BLOCK forStruc 
        | BLOCK arrayIns ENDEXPR
        | BLOCK varInsAsig 
        | BLOCK arrayInsAsign
        | BLOCK printStruc ENDEXPR
        | BLOCK BREAK ENDEXPR {:if(breakSwitch) {cod3D.append("\ngoto endSwitchStruc" + currentStruc);}
                                :}
        | BLOCK inputStruc
        | BLOCK arrayAsig
        | BLOCK returnStruc
        | exprP ENDEXPR
        | arrayIns ENDEXPR
        | arrayInsAsign
        | mainStruc 
        | funcStruc 
        | varAsig    
        | arrayInsGl ENDEXPR
        | varInsGl ENDEXPR
        | varInsAsigGl
        | arrayInsAsignGl
        | varInsAsig 
        | varIns ENDEXPR
        | ifStrucComplete 
        | ifElseStruc
        | switchStruc
        | forStruc
        | arrayAsig
        | whileStruc
        | returnStruc
        | printStruc ENDEXPR
        | BREAK ENDEXPR {:if(breakSwitch) {cod3D.append("\ngoto endSwitchStruc" + currentStruc);}:}
        | inputStruc
        | error;


numbers ::= INTEGER_LITERAL:lit {: RESULT = lit + ":" + "INT";:}
        | FLOATNUM:lit {:RESULT = lit + ":" + "FLOAT";:};

//Operaciones aritmeticas simples entre dos numeros
/* Reglas de producción para operaciones aritméticas */
compAritOp ::= term:op2 {:RESULT = op2;:}
             //| compAritOp MINPLS term  {: System.out.println("Se hizo MULTIPLESIMB"); :}
                | compAritOp:op1 PLUS term:op2  {: 
                                                String[] elementos1 = op1.toString().split(":");
                                                String[] elementos2 = op2.toString().split(":");
                                                if(!elementos1[1].equals(elementos2[1])) {System.out.println("Error semantico, en esta suma los operadores deben ser del mismo tipo"); System.exit(0);} else 
                                                {String baseTemp = "t";
                                                    String miTempId;

                                                    if (elementos1[1].equals("FLOAT")) {
                                                        baseTemp = "f";
                                                        currentFloat++;
                                                        miTempId = baseTemp + currentFloat;}
                                                    else {
                                                        currentTemp++;
                                                        miTempId = baseTemp + currentTemp;}
                                                    
                                                    cod3D.append("\n" + miTempId + "=" + elementos1[0] + "+" + elementos2[0]);

                                                    RESULT = miTempId + ":" + elementos1[1];}:}
                | compAritOp:op1 MINUSW term:op2  {: 
                                                String[] elementos1 = op1.toString().split(":");
                                                String[] elementos2 = op2.toString().split(":");
                                                if(!elementos1[1].equals(elementos2[1])) {System.out.println("Error semantico, en esta resta los operadores deben ser del mismo tipo");System.exit(0);} 
                                                else {
                                                    String baseTemp = "t";
                                                    String miTempId;

                                                    if (elementos1[1].equals("FLOAT")) {
                                                        baseTemp = "f";
                                                        currentFloat++;
                                                        miTempId = baseTemp + currentFloat;}
                                                    else {
                                                        currentTemp++;
                                                        miTempId = baseTemp + currentTemp;}
                                                    
                                                    cod3D.append("\n" + miTempId + "=" + elementos1[0] + "-" + elementos2[0]);

                                                    RESULT = miTempId + ":" + elementos1[1];}:};

term       ::= factor:op2 {:RESULT = op2;:}
                | term:op1 PRODUCT factor:op2  {: 
                                                String[] elementos1 = op1.toString().split(":");
                                                String[] elementos2 = op2.toString().split(":");
                                                if(!elementos1[1].equals(elementos2[1])) {System.out.println("Error semantico, en este producto los operadores deben ser del mismo tipo");System.exit(0);} else 
                                                {String baseTemp = "t";
                                                    String miTempId;

                                                    if (elementos1[1].equals("FLOAT")) {
                                                        baseTemp = "f";
                                                        currentFloat++;
                                                        miTempId = baseTemp + currentFloat;}
                                                    else {
                                                        currentTemp++;
                                                        miTempId = baseTemp + currentTemp;}
                                                    
                                                    cod3D.append("\n" + miTempId + "=" + elementos1[0] + "*" + elementos2[0]);

                                                    RESULT = miTempId + ":" + elementos1[1];}:}
                | term:op1 DIVISION factor:op2  {: 
                                                String[] elementos1 = op1.toString().split(":");
                                                String[] elementos2 = op2.toString().split(":");
                                                if(!elementos1[1].equals(elementos2[1])) {System.out.println("Error semantico, en este cociente los operadores deben ser del mismo tipo");System.exit(0);} 
                                                else {String baseTemp = "t";
                                                    String miTempId;

                                                    if (elementos1[1].equals("FLOAT")) {
                                                        baseTemp = "f";
                                                        currentFloat++;
                                                        miTempId = baseTemp + currentFloat;}
                                                    else {
                                                        currentTemp++;
                                                        miTempId = baseTemp + currentTemp;}
                                                    
                                                    cod3D.append("\n" + miTempId + "=" + elementos1[0] + "/" + elementos2[0]);

                                                    RESULT = miTempId + ":" + elementos1[1];}:}
                | term:op1 POWER factor:op2   {: 
                                                String[] elementos1 = op1.toString().split(":");
                                                String[] elementos2 = op2.toString().split(":");
                                                if(!elementos1[1].equals(elementos2[1])) {System.out.println("Error semantico, en esta potencia los operadores deben ser del mismo tipo");System.exit(0);} else 
                                                {String baseTemp = "t";
                                                    String miTempId;

                                                    if (elementos1[1].equals("FLOAT")) {
                                                        baseTemp = "f";
                                                        currentFloat++;
                                                        miTempId = baseTemp + currentFloat;}
                                                    else {
                                                        currentTemp++;
                                                        miTempId = baseTemp + currentTemp;}
                                                    
                                                    cod3D.append("\n" + miTempId + "=" + elementos1[0] + "^" + elementos2[0]);

                                                    RESULT = miTempId + ":" + elementos1[1];}:}  
                | term:op1 MODULUS factor:op2   {: 
                                                String[] elementos1 = op1.toString().split(":");
                                                String[] elementos2 = op2.toString().split(":");
                                                if(!elementos1[1].equals(elementos2[1])) {System.out.println("Error semantico, en este modulo los operadores deben ser del mismo tipo");System.exit(0);} else 
                                                {String baseTemp = "t";
                                                    String miTempId;

                                                    if (elementos1[1].equals("FLOAT")) {
                                                        baseTemp = "f";
                                                        currentFloat++;
                                                        miTempId = baseTemp + currentFloat;}
                                                    else {
                                                        currentTemp++;
                                                        miTempId = baseTemp + currentTemp;}
                                                    
                                                    cod3D.append("\n" + miTempId + "=" + elementos1[0] + "%" + elementos2[0]);

                                                    RESULT = miTempId + ":" + elementos1[1];}:};

factor     ::= numbers:numero {:
                String[] elementos = numero.toString().split(":");
                if (elementos[1].equals("FLOAT")) {   
                    currentFloat++;             
                    String miTempId = "f"+currentFloat;
                    cod3D.append("\n" +  miTempId + "=" + elementos[0])
                    ;}
                else {    
                    currentTemp++;            
                    String miTempId = "t"+currentTemp;
                    cod3D.append("\n" +  miTempId + "=" + elementos[0])
                    ;}

                RESULT = numero;:}

                | MINUSW numbers:numero {:RESULT = numero;:}
                | STRING_LITERAL:lit {:
                                currentTemp++;
                                String miTempId = "t"+currentTemp;
                                cod3D.append("\n" +  miTempId + "=" + lit.toString());
                                RESULT = miTempId.trim() + ":STRING";:}

                | CHARSTR:lit {:
                        currentTemp++;
                        String miTempId = "t"+currentTemp;
                        cod3D.append("\n" +  miTempId + "=" + lit.toString());
                        RESULT = miTempId.trim() + ":CHAR";:}

                | IDENTIFIER:ID {:
                                String tipo = getTipo(ID.toString()); 
                                String baseTemp = "t";
                                String miTempId;
                                if (tipo.equals("FLOAT")) {
                                    baseTemp = "f";
                                    currentFloat++;
                                    miTempId = baseTemp + currentFloat;}
                                else {
                                    currentTemp++;
                                    miTempId = baseTemp + currentTemp;}

                                cod3D.append("\n" + miTempId + "=" + ID.toString());

                                RESULT = miTempId.trim() + ":" + tipo;:}

                | IDENTIFIER:ID DMINUS {:String tipo = getTipo(ID.toString()); 
                                        String baseTemp = "t";
                                        String miTempId;
                                        if (tipo.equals("FLOAT")) {
                                            baseTemp = "f";
                                            currentFloat++;
                                            miTempId = baseTemp + currentFloat;}
                                        else {
                                            currentTemp++;
                                            miTempId = baseTemp + currentTemp;}
                                        cod3D.append("\n" + miTempId + "=" + ID.toString());
                                        currentTemp++;
                                        String miTemp1 = baseTemp + currentTemp;
                                        currentTemp++;
                                        String miTemp2 = baseTemp + currentTemp;

                                        cod3D.append("\n" + miTemp1 + " = 1");
                                        cod3D.append("\n" + miTemp2 + " = " + miTempId + "-" + miTemp1);
                                        cod3D.append("\n" + ID.toString() + " = " + miTemp2);
                                        
                                        RESULT = ID.toString().trim() + ":" + tipo;:} 

                | IDENTIFIER:ID DPLUS {:String tipo = getTipo(ID.toString()); 
                                        String baseTemp = "t";
                                        String miTempId;
                                        if (tipo.equals("FLOAT")) {
                                            baseTemp = "f";
                                            currentFloat++;
                                            miTempId = baseTemp + currentFloat;}
                                        else {
                                            currentTemp++;
                                            miTempId = baseTemp + currentTemp;}
                                        cod3D.append("\n" + miTempId + "=" + ID.toString());
                                        currentTemp++;
                                        String miTemp1 = baseTemp + currentTemp;
                                        currentTemp++;
                                        String miTemp2 = baseTemp + currentTemp;

                                        cod3D.append("\n" + miTemp1 + " = 1");
                                        cod3D.append("\n" + miTemp2 + " = " + miTempId + "+" + miTemp1);
                                        cod3D.append("\n" + ID.toString() + " = " + miTemp2);
                                        
                                        RESULT = ID.toString().trim() + ":" + tipo;:}

                | arrayElement:arrE {:RESULT = arrE;:}
                | paramList:pLis {:RESULT = pLis;:}
                | funcInvo:funI {:RESULT = funI;:}
                | MINUSW PARENTS compAritOp:comp PARENTC {:RESULT = comp;:}
                | PARENTS compAritOp:comp PARENTC {:RESULT = comp;:};  


inputStruc ::= INPUT PARENTS IDENTIFIER:ID PARENTC ENDEXPR {: 
                    String tipo = getTipo(ID.toString());
                    boolean existe = existeVar(ID.toString(), tipo);
                    boolean existe2 = existeVarGlob(ID.toString(), tipo);

                    if (!existe && !existe2) {System.out.println("ERROR -> La variable debe estar declarada antes de usarse en el input");System.exit(0);}

                    cod3D.append("\n" + ID.toString() + " = call input");
                :};


//Manejo de distintas expresiones de comparacion y union
exprP ::= exprLog:expL {:RESULT = expL;:} 
        | compAritOp:comp {:RESULT = comp;:}      
        | exprUni:expU {:RESULT = expU;:} ;

exprLog ::= compAritOp:op1 opRel:op compAritOp:op2 {: 
                                                    String[] elementos1 = op1.toString().split(":");
                                                    String[] elementos2 = op2.toString().split(":");

                                                    if(!elementos1[1].equals(elementos2[1])) {System.out.println("Error, la comparacion debe ser entre valores del mismo tipo"); System.exit(0); RESULT = elementos1[0] + ":" + "NULL";} else 
                                                    {
                                                    String baseTemp = "t";
                                                    if (elementos1[1].equals("FLOAT")) {baseTemp = "f";}


                                                    int x = currentTemp - 1;
                                                    int y = x + 1;
                                                    currentTemp++;
                                                    String miTempId3 = baseTemp + currentTemp + " = " + baseTemp + y + op.toString() + "t" + x;
                                                    cod3D.append("\n" + miTempId3);

                                                    RESULT = baseTemp + currentTemp + ":" + "BOOL";} :}
        | PARENTS exprLog:op2 PARENTC {:RESULT = op2;:}
        | opRel exprLog:op2 {:RESULT = op2;:}
        | TRUE {:RESULT = "TRUE:BOOL";:} 
        | FALSE {:RESULT = "FALSE:BOOL";:};

exprUni ::= exprLog:op1 opLog:op exprP:op2  {: String[] elementos1 = op1.toString().split(":");
                                            String[] elementos2 = op2.toString().split(":");
                                            
                                            if(elementos1[1].equals("BOOL") && elementos2[1].equals("BOOL")) 
                                            {
                                                String baseTemp = "t";

                                                int x = currentTemp - 2;
                                                int y = x + 1;
                                                
                                                currentTemp++;
                                                String miTempId3 = baseTemp + currentTemp + " = t" + y + op.toString() + "t" + x;
                                                cod3D.append("\n" + miTempId3);

                                                RESULT = baseTemp + currentTemp + ":" + "BOOL";} 

                                            else {System.out.println("Ambos operadores deben ser booleanos");System.exit(0); RESULT = elementos1[0] + ":" + "NULL";}:}
        | IDENTIFIER:ID opLog:op exprP:op2  {: 
                                            String tipo = getTipo(ID.toString());
                                            String[] elementos1 = op2.toString().split(":");
                                            
                                            if(tipo.equals("BOOL") && elementos1[1].equals("BOOL")) 
                                            {
                                                
                                                String baseTemp = "t";

                                                int x = currentTemp - 1;
                                                int y = x + 1;

                                                currentTemp++;
                                                String miTempId3 = baseTemp + currentTemp + " = t" + y + op.toString() + "t" + x;

                                                cod3D.append("\n" + miTempId3);

                                                RESULT = baseTemp + currentTemp + ":" + "BOOL";} 
                                            else {System.out.println("Ambos operadores deben ser booleanos");System.exit(0); RESULT = elementos1[0] + ":" + "NULL";} :}
        | PARENTS exprUni PARENTC;

opRel ::= GRATHER {:RESULT = ">";:} | GRATHERT {:RESULT = ">=";:}  | LOWER {:RESULT = "<";:}  | LOWERT {:RESULT = "<=";:}  | DIFF {:RESULT = "!=";:}  | COMPARATION {:RESULT = "==";:}  | NEGATION {:RESULT = "!";:} ;
opLog ::= AND {:RESULT = "&&";:} 
        | OR {:RESULT = "||";:};

//Asignación de un valor a una variable
varAsig      ::=  IDENTIFIER:ID EQ exprP:val ENDEXPR  {: 
                                                    String tipo = getTipo(ID.toString());
                                                    boolean existe = existeVar(ID.toString(), tipo);
                                                    boolean existe2 = existeVarGlob(ID.toString(), tipo);
                                                    if (!existe && !existe2) {System.out.println("Esta variable -> " + ID.toString() + " <- no existe");System.exit(0);}
                                                    String[] valores = val.toString().split(":");
                                                    
                                                    //currentTemp++;
                                                    String baseTemp = "t";
                                                    if (tipo.equals("FLOAT")) {baseTemp = "f";}
                                                    //cod3D.append("\n" + baseTemp + currentTemp + " = " + valores[0]);
                                                    cod3D.append("\n" + ID.toString() + " = " + baseTemp + currentTemp);

                                                    if(!tipo.equals(valores[1])) {System.out.println("Error semantico, el tipo de la variable no coincide con el asignado");System.exit(0);} else {RESULT = tipo;}:}
                | EQ exprP:val ENDEXPR {:
                                        RESULT = val;:};


//Instanciacion simple de variables
varIns       ::= LOC SEP INT SEP IDENTIFIER:ID    {:
                                                    boolean existe = existeVar(ID.toString(), "INT");
                                                    if (existe) {System.out.println("La variable local -> " + ID.toString() + " <- ya fue declarada");System.exit(0);}  
                                                    scopePrograma.get(currentHash).add("Instancia loc: " + ID.toString() + ":" + "INT");  

                                                    cod3D.append("\nlocal_data_int " + ID.toString());

                                                    RESULT = ID.toString() + ":" + "INT";:}
                | LOC SEP CHAR SEP IDENTIFIER:ID     {: 
                                                    boolean existe = existeVar(ID.toString(), "CHAR");
                                                    if (existe) {System.out.println("La variable local -> " + ID.toString() + " <- ya fue declarada");System.exit(0);}  
                                                    scopePrograma.get(currentHash).add("Instancia loc: " + ID.toString() + ":" + "CHAR");  

                                                    cod3D.append("\nlocal_data_char " + ID.toString());

                                                    RESULT = ID.toString() + ":" + "CHAR";:}   
                | LOC SEP FLOAT SEP IDENTIFIER:ID    {: 
                                                    boolean existe = existeVar(ID.toString(), "FLOAT");
                                                    if (existe) {System.out.println("La variable local -> " + ID.toString() + " <- ya fue declarada");System.exit(0);} 
                                                    scopePrograma.get(currentHash).add("Instancia loc: " + ID.toString() + ":" + "FLOAT");  

                                                    cod3D.append("\nlocal_data_float " + ID.toString());

                                                    RESULT = ID.toString() + ":" + "FLOAT";:}
                | LOC SEP BOOL SEP IDENTIFIER:ID     {: 
                                                    boolean existe = existeVar(ID.toString(), "BOOL");
                                                    if (existe) {System.out.println("La variable local -> " + ID.toString() + " <- ya fue declarada");System.exit(0);}  
                                                    scopePrograma.get(currentHash).add("Instancia loc: " + ID.toString() + ":" + "BOOL");  

                                                    cod3D.append("\nlocal_data_bool " + ID.toString());

                                                    RESULT = ID.toString() + ":" + "BOOL";:}  
                | LOC SEP STRINGT SEP IDENTIFIER:ID  {: 
                                                    boolean existe = existeVar(ID.toString(), "STRING");
                                                    if (existe) {System.out.println("La variable local -> " + ID.toString() + " <- ya fue declarada");System.exit(0);} 
                                                    scopePrograma.get(currentHash).add("Instancia loc: " + ID.toString() + ":" + "STRING"); 

                                                    cod3D.append("\nlocal_data_string " + ID.toString());

                                                    RESULT = ID.toString() + ":" + "STRING";:};



varInsGl     ::=  GLOB SEP INT SEP IDENTIFIER:ID     {: 
                                                        boolean existe = existeVarGlob(ID.toString(), "INT");
                                                        if (existe) {System.out.println("La variable global -> " + ID.toString() + " <- ya fue declarada");System.exit(0);}
                                                        scopePrograma.get(globalHash).add("Instancia GLOB: " + ID.toString() + ":" + "INT"); 

                                                        cod3D.append("\nglobal_data_int " + ID.toString());

                                                        RESULT = ID.toString() + ":" + "INT";:}
                | GLOB SEP CHAR SEP IDENTIFIER:ID       {:          
                                                        boolean existe = existeVarGlob(ID.toString(), "CHAR");
                                                        if (existe) {System.out.println("La variable global -> " + ID.toString() + " <- ya fue declarada");System.exit(0);} 
                                                        scopePrograma.get(globalHash).add("Instancia GLOB: " + ID.toString() + ":" + "CHAR");

                                                        cod3D.append("\nglobal_data_char " + ID.toString());

                                                        RESULT = ID.toString() + ":" + "CHAR";:}
                | GLOB SEP FLOAT SEP IDENTIFIER:ID      {:
                                                        boolean existe = existeVarGlob(ID.toString(), "FLOAT");
                                                        if (existe) {System.out.println("La variable global -> " + ID.toString() + " <- ya fue declarada");System.exit(0);}
                                                        scopePrograma.get(globalHash).add("Instancia GLOB: " + ID.toString() + ":" + "FLOAT"); 

                                                        cod3D.append("\nglobal_data_float " + ID.toString());

                                                        RESULT = ID.toString() + ":" + "FLOAT";:}
                | GLOB SEP STRINGT SEP IDENTIFIER:ID    {:
                                                        boolean existe = existeVarGlob(ID.toString(), "STRING");
                                                        if (existe) {System.out.println("La variable global -> " + ID.toString() + " <- ya fue declarada");System.exit(0);}
                                                        scopePrograma.get(globalHash).add("Instancia GLOB: " + ID.toString() + ":" + "STRING"); 

                                                        cod3D.append("\nglobal_data_string " + ID.toString());

                                                        RESULT = ID.toString() + ":" + "STRING";:}
                | GLOB SEP BOOL SEP IDENTIFIER:ID       {: 
                                                        boolean existe = existeVarGlob(ID.toString(), "BOOL");
                                                        if (existe) {System.out.println("La variable global -> " + ID.toString() + " <- ya fue declarada");System.exit(0);}
                                                        scopePrograma.get(globalHash).add("Instancia GLOB: " + ID.toString() + ":" + "BOOL"); 

                                                        cod3D.append("\nglobal_data_bool " + ID.toString());

                                                        RESULT = ID.toString() + ":" + "BOOL";:};

varInsAsig   ::= varIns:t1 varAsig:t2 {:
                                        String[] valores1 = t1.toString().split(":");
                                        String[] valores2 = t2.toString().split(":");

                                        String baseTemp = "t";
                                        if (valores1[1].equals("FLOAT")) {baseTemp = "f";}
                                        
                                        cod3D.append("\n" + valores1[0] + " = " + baseTemp + currentTemp);

                                        if (!valores1[1].equals(valores2[1])) {System.out.println("ERROR VAR LOCAL-> El tipo de variable no coincide con el asignado");System.exit(0);}:};

varInsAsigGl   ::= varInsGl:t1 varAsig:t2 {:
                                        String[] valores1 = t1.toString().split(":");
                                        String[] valores2 = t2.toString().split(":");
                                        String baseTemp = "t";
                                        if (valores1[1].equals("FLOAT")) {baseTemp = "f";}
                                        
                                        cod3D.append("\n" + valores1[0] + " = " + baseTemp + currentTemp);

                                        if (!valores1[1].equals(valores2[1])) {System.out.println("ERROR VAR GLOB-> El tipo de variable no coincide con el asignado");System.exit(0);}:};

funInitial   ::= FUNC SEP INT SEP IDENTIFIER:ID
                        {:   String tipo;
                                                            boolean existe = existeFun(ID.toString(), "INT");
                                                            if (existe) {System.out.println("La funcion -> " + ID.toString() + " <- ya fue declarada");System.exit(0);} 
                                                            tipo = "tipo:func:INT";
                                                            ArrayList<String> fun = new ArrayList<String>();
                                                            currentHash = ID.toString();
                                                            fun.add(tipo);
                                                            scopePrograma.put(currentHash, fun);

                                                            cod3D.append("\n\nbegin_func_" + ID.toString()+":");
                                                            currentTemp = 0;
                                                            currentFloat = 0;
                                                            currentParam = 0;
                                                            currentReturns = 0;

                                                            RESULT = "INT";
                        :}
                | FUNC SEP CHAR SEP IDENTIFIER:ID
                        {:   String tipo;
                                                            boolean existe = existeFun(ID.toString(), "CHAR");
                                                            if (existe) {System.out.println("La funcion -> " + ID.toString() + " <- ya fue declarada");System.exit(0);} 
                                                            tipo = "tipo:func:CHAR";
                                                            ArrayList<String> fun = new ArrayList<String>();
                                                            currentHash = ID.toString();
                                                            fun.add(tipo);
                                                            scopePrograma.put(currentHash, fun);

                                                            cod3D.append("\n\nbegin_func_" + ID.toString()+":");
                                                            currentTemp = 0;
                                                            currentFloat = 0;
                                                            currentParam = 0;
                                                            currentReturns = 0;

                                                            RESULT = "CHAR";
                        :}
                | FUNC SEP BOOL SEP IDENTIFIER:ID
                        {:   String tipo;
                                                            boolean existe = existeFun(ID.toString(), "BOOL");
                                                            if (existe) {System.out.println("La funcion -> " + ID.toString() + " <- ya fue declarada");System.exit(0);} 
                                                            tipo = "tipo:func:BOOL";
                                                            ArrayList<String> fun = new ArrayList<String>();
                                                            currentHash = ID.toString();
                                                            fun.add(tipo);
                                                            scopePrograma.put(currentHash, fun);

                                                            cod3D.append("\n\nbegin_func_" + ID.toString()+":");
                                                            currentTemp = 0;
                                                            currentFloat = 0;
                                                            currentParam = 0;
                                                            currentReturns = 0;

                                                            RESULT = "BOOL";
                        :}
                | FUNC SEP STRINGT SEP IDENTIFIER:ID
                        {:   String tipo;
                                                            boolean existe = existeFun(ID.toString(), "STRING");
                                                            if (existe) {System.out.println("La funcion -> " + ID.toString() + " <- ya fue declarada");System.exit(0);} 
                                                            tipo = "tipo:func:STRING";
                                                            ArrayList<String> fun = new ArrayList<String>();
                                                            currentHash = ID.toString();
                                                            fun.add(tipo);
                                                            scopePrograma.put(currentHash, fun);

                                                            cod3D.append("\n\nbegin_func_" + ID.toString()+":");
                                                            currentTemp = 0;
                                                            currentFloat = 0;
                                                            currentParam = 0;
                                                            currentReturns = 0;

                                                            RESULT = "STRING";
                        :}
                | FUNC SEP FLOAT SEP IDENTIFIER:ID
                        {:   String tipo;
                                                            boolean existe = existeFun(ID.toString(), "FLOAT");
                                                            if (existe) {System.out.println("La funcion -> " + ID.toString() + " <- ya fue declarada");System.exit(0);} 
                                                            tipo = "tipo:func:FLOAT";
                                                            ArrayList<String> fun = new ArrayList<String>();
                                                            currentHash = ID.toString();
                                                            fun.add(tipo);
                                                            scopePrograma.put(currentHash, fun);

                                                            cod3D.append("\n\nbegin_func_" + ID.toString()+":");
                                                            currentTemp = 0;
                                                            currentFloat = 0;
                                                            currentParam = 0;
                                                            currentReturns = 0;

                                                            RESULT = "FLOAT";
                        :};

//Declaracion inicial del bloque para las funciones
funcStruc    ::= funInitial DELIMETERBLOCK BLOCK DELIMETERBLOCK {:if (currentReturns.equals(0)) {System.out.println("ERROR -> Las funciones deben tener al menos un retorno");System.exit(0);}:};  

mainInitial  ::= FUNC SEP INT SEP MAIN 
                        {:                              
                                                        if (scopePrograma.get("MAIN") != null) {System.out.println("Ya existe una funcion main");System.exit(0);}
                                                        String tipo;
                                                        tipo = "tipo:MAIN:INT";
                                                        ArrayList<String> fun = new ArrayList<String>();
                                                        currentHash = "MAIN";
                                                        fun.add(tipo);

                                                        cod3D.append("\nbegin_main_:");
                                                        currentTemp = 0;
                                                        currentFloat = 0;
                                                        currentParam = 0;
                                                        currentReturns = 0;

                                                        scopePrograma.put(currentHash, fun);
                            :};

mainStruc    ::= mainInitial DELIMETERBLOCK BLOCK DELIMETERBLOCK {: if (currentReturns.equals(0)) {System.out.println("ERROR -> Las funciones deben tener al menos un retorno");System.exit(0);} :};

paramFunc    ::= exprP COMA paramFunc {: cantParams++; :}
                | exprP {: cantParams++; :};

funcInvo     ::= IDENTIFIER:ID PARENTS paramFunc PARENTC {: 
                                                            String tipo = getTipoFunc(ID.toString()); 
                                                            boolean existe = existeFun(ID.toString(), tipo);
                                                            if (!existe) {System.out.println("ERROR -> La funcion llamada no ha sido declarada");System.exit(0);}
                                                            currentTemp++;
                                                            String baseTemp = "t";
                                                            if (tipo.equals("FLOAT")) {baseTemp = "f";}
                                                            
                                                            cod3D.append("\n" + baseTemp + currentTemp + "= call " + ID.toString() + ", " + cantParams);
                                                            
                                                            Integer numberOfParams = countParam(ID.toString());
                                                            if (!numberOfParams.equals(cantParams)) {System.out.println("ERROR -> La cantidad de parametros enviados no coincide con los esperados por la funcion");System.exit(0);}
                                                            cantParams = 0;

                                                            RESULT = tipo; :}

                | IDENTIFIER:ID PARENTS PARENTC {:          String tipo = getTipoFunc(ID.toString()); 
                                                            currentTemp++;
                                                            String baseTemp = "t";
                                                            if (tipo.equals("FLOAT")) {baseTemp = "f";}
                                                            
                                                            cod3D.append("\n" + baseTemp + currentTemp + "= call " + ID.toString() + ", " + cantParams);
                                                            boolean existe = existeFun(ID.toString(), tipo);
                                                            if (!existe) {System.out.println("ERROR -> La funcion llamada no ha sido declarada");System.exit(0);}
                                                            Integer numberOfParams = countParam(ID.toString());
                                                            if (!numberOfParams.equals(0)) {System.out.println("ERROR -> La cantidad de parametros enviados no coincide con los esperados por la funcion");System.exit(0);}
                                                            RESULT = tipo; :};



ifStruc      ::= {: currentStruc++;
                cod3D.append("\nif_begin" + currentStruc + ":"); :}
                IF PARENTS exprP:val PARENTC
                {:String[] elementos1 = val.toString().split(":");
                cod3D.append("\nif " + elementos1[0] + " goto ifblock" + currentStruc);
                cod3D.append("\ngoto else_begin" + currentStruc);
                cod3D.append("\nifblock" + currentStruc + ":");:};

ifStrucComplete ::= ifStruc DELIMETERBLOCK BLOCK DELIMETERBLOCK 
                                                            {: cod3D.append("\nif_end" + currentStruc + ":"); :};

ifElseStruc  ::= 
            ifStrucComplete elseStruc;

elseStruc ::= {: cod3D.append("\nelse_begin" + currentStruc + ":"); :} ELSE DELIMETERBLOCK BLOCK DELIMETERBLOCK
            {: cod3D.append("\nelse_end" + currentStruc + ":"); :};
//Produccion while

whileBegin ::= {:currentStruc++;
                cod3D.append("\nwhile_begin" + currentStruc + ":"); :}
            WHILE PARENTS exprP:val PARENTC
            {:  String[] elementos1 = val.toString().split(":");
                cod3D.append("\nif " + elementos1[0] + " goto whileBlock" + currentStruc);
                cod3D.append("\ngoto end_while" + currentStruc);
                cod3D.append("\nwhileBlock" + currentStruc + ":");
                RESULT = elementos1[0];:};

whileStruc   ::= whileBegin:val DELIMETERBLOCK BLOCK DELIMETERBLOCK
                {:
                cod3D.append("\nend_block_while" + currentStruc + ":");
                cod3D.append("\nif " + val.toString() + " goto whileBlock" + currentStruc);
                cod3D.append("\nend_while" + currentStruc + ":");:};

//Declaracion, asignacion y acceso a un array
arrayIns ::=  LOC SEP INT SEP ARRAY SEP IDENTIFIER:ID SQUARES INTEGER_LITERAL SQUAREC {: 
                                                                                        boolean existe = existeArr(ID.toString(), "INT");
                                                                                        if (existe) {System.out.println("El array local -> " + ID.toString() + " <- ya fue declarado");System.exit(0);}  
                                                                                        scopePrograma.get(currentHash).add("Instancia LOC ARR: " + ID.toString() + ":" + "INT"); 
                                                                                        cod3D.append("\nlocal_data_arr_int " + ID.toString());

                                                                                        RESULT = ID.toString() + ":" + "INT";:}
            | LOC SEP CHAR SEP ARRAY SEP IDENTIFIER:ID SQUARES INTEGER_LITERAL SQUAREC {: 
                                                                                        boolean existe = existeArr(ID.toString(), "CHAR");
                                                                                        if (existe) {System.out.println("El array local -> " + ID.toString() + " <- ya fue declarado");System.exit(0);}
                                                                                        scopePrograma.get(currentHash).add("Instancia LOC ARR: " + ID.toString() + ":" + "CHAR"); 
                                                                                        cod3D.append("\nlocal_data_arr_char " + ID.toString());

                                                                                        RESULT = ID.toString() + ":" + "CHAR";:};

arrayInsGl ::=  GLOB SEP INT SEP ARRAY SEP IDENTIFIER:ID SQUARES INTEGER_LITERAL SQUAREC  {: 
                                                                                        boolean existe = existeArrGlob(ID.toString(), "INT");
                                                                                        if (existe) {System.out.println("El array global -> " + ID.toString() + " <- ya fue declarado");System.exit(0);}
                                                                                        scopePrograma.get(globalHash).add("Instancia GLOB ARR: " + ID.toString() + ":" + "INT"); 
                                                                                        cod3D.append("\nglobal_data_arr_int " + ID.toString());

                                                                                        RESULT = ID.toString() + ":" + "INT";;:}
            | GLOB SEP CHAR SEP ARRAY SEP IDENTIFIER:ID SQUARES INTEGER_LITERAL SQUAREC {: 
                                                                                        boolean existe = existeArrGlob(ID.toString(), "CHAR");
                                                                                        if (existe) {System.out.println("El array global -> " + ID.toString() + " <- ya fue declarado");System.exit(0);}
                                                                                        scopePrograma.get(globalHash).add("Instancia GLOB ARR: " + ID.toString() + ":" + "CHAR"); 
                                                                                        cod3D.append("\nglobal_data_arr_char " + ID.toString());

                                                                                        RESULT = ID.toString() + ":" + "CHAR";;:};

//Declaracion de ARRAYS Y TODO LO RELACIONADO
arrayAsig ::= IDENTIFIER:ID EQ SQUARES elementos SQUAREC ENDEXPR {:
                                                                        String tipo = getTipo(ID.toString());
                                                                        boolean existe = existeArr(ID.toString(), tipo);
                                                                        boolean existe2 = existeArrGlob(ID.toString(), tipo);
                                                                        if (!existe && !existe2) {System.out.println("Este array -> " + ID.toString() + " <- no existe");}
                                                                        writeAsignArr(ID.toString());

                                                                        if (!todosIguales(elementosArray)) {System.out.println("Los elementos asignados deben coincidir en tipo entre ellos y de acuerdo al arreglo");System.exit(0);}
                                                                        elementosArray.clear();
                                                                        RESULT = ID.toString() + ":" + tipo;:}
            | EQ SQUARES elementos:elem SQUAREC ENDEXPR {:RESULT = elem;:};

elementos ::= compAritOp:val1 COMA elementos:val2 {:String[] elementos1 = val1.toString().split(":");
                                                    elementosArray.add(elementos1[1]);:}
            | compAritOp:val1 {: 
                                String[] elementos1 = val1.toString().split(":");
                                elementosArray.add(elementos1[1]);; :};

arrayInsAsign ::= arrayIns:t1 arrayAsig:t2 {:
                                            String[] elementos1 = t1.toString().split(":");
                                            if (!todosIguales(elementosArray)) {System.out.println("Los elementos asignados deben coincidir en tipo entre ellos y de acuerdo al arreglo");System.exit(0);}
                                            String tipo = elementosArray.get(0);
                                            writeAsignArr(elementos1[0]);
                                            if (!elementos1[1].equals(tipo)) {System.out.println("ERROR ARRAY LOC -> No todos los valores coinciden con el tipo instanciado");System.exit(0);};
                                            elementosArray.clear();:};

arrayInsAsignGl ::= arrayInsGl:t1 arrayAsig:t2 {:
                                            String[] elementos1 = t1.toString().split(":");
                                            if (!todosIguales(elementosArray)) {System.out.println("Los elementos asignados deben coincidir en tipo entre ellos y de acuerdo al arreglo");System.exit(0);}
                                            String tipo = elementosArray.get(0);
                                            writeAsignArr(elementos1[0]);
                                            if (!elementos1[1].equals(tipo)) {System.out.println("ERROR ARRAY GLOB -> No todos los valores coinciden con el tipo instanciado");System.exit(0);}
                                            elementosArray.clear();:};

arrayElement ::= IDENTIFIER:ID SQUARES INTEGER_LITERAL:lit SQUAREC {: currentTemp++;
                                                                cod3D.append("\nt" + currentTemp + " = " + ID.toString() + ", " + lit);
                                                                String tipo = getTipo(ID.toString()); RESULT = "t" + currentTemp + ":" + tipo; :};


//Declaracion de switch
switchBegin ::= {: 
                breakSwitch = true;
                currentStruc++;
                casesCont = 0;
                casesContRes = 0;
                cod3D.append("\nswitchBegin" + currentStruc + ":");
                String mitemp1 = "\nlocal_data_int flag";
                cod3D.append(mitemp1);
                cod3D.append("\nflag = 1");
                :}
                SWITCH PARENTS IDENTIFIER:ID PARENTC {: idSwitch = ID.toString(); :};
switchStruc ::= switchBegin DELIMETERBLOCK caseStruc defaultStruc DELIMETERBLOCK {:cod3D.append("\nendSwitchStruc" + currentStruc + ":"); breakSwitch = false;:};

caseStrucBegin ::= CASE SEP compAritOp:val SEP{:
            casesCont++;
            cod3D.append("\ncaseCond" + casesCont + ":");
            cod3D.append("\nif flag == 1 goto caseBlockEntry" + casesCont);
            cod3D.append("\ngoto caseEndBlock" + casesCont);

            String tipo = getTipo(idSwitch);
            String[] elementos = val.toString().split(":");
            if (!tipo.equals(elementos[1])) {System.out.println("ERROR: El valor del case no es igual al de la variable a comparar");System.exit(0);}

            cod3D.append("\ncaseBlockEntry" + casesCont + ":");
            cod3D.append("\nif " + idSwitch + " == " + elementos[0] + " goto caseBlock" + casesCont);
            cod3D.append("\ngoto caseEndBlock" + casesCont);
            cod3D.append("\ncaseBlock" + casesCont + ":");
            cod3D.append("\nflag = 0");
            :};

caseMid ::= BLOCK {:
                    Integer x = casesCont + 1;
                    cod3D.append("\ngoto caseBlock" + x);:};

caseStruc ::= 
            caseStrucBegin caseMid caseStruc {:
            Integer x = casesCont - casesContRes;
            Integer y = x + 1;

            cod3D.append("\ncaseEndBlock" + x + ":");
            cod3D.append("\ngoto caseCond" + y);
            casesContRes++;
            :}
            | caseStrucBegin BLOCK {:
            Integer x = casesCont - casesContRes;
            
            cod3D.append("\ncaseEndBlock" + x + ":");
            cod3D.append("\ngoto defaultBlock");
            casesContRes++;
            :};

defaultStruc ::= {:cod3D.append("\ndefaultBlock" + casesCont + ":");
                :} 
                DEFAULT SEP BLOCK {:
                cod3D.append("\ndefaultEndBlock" + casesCont + ":");
                cod3D.append("\ngoto endSwitchStruc" + casesCont);:};

//Declaracion de FOR
forStrucBegin ::= FOR SEP IDENTIFIER:val SEP IN SEP RANGE PARENTS exprP:expr1 PARENTC {: 
                                            currentStruc++;  
                                            String[] elementos1 = expr1.toString().split(":");
                                            if(!elementos1[1].equals("INT")) {System.out.println("ERROR SEMANTICO -> Los parametros del range deben ser de tipo entero");System.exit(0);}
                                            
                                            cod3D.append("\nfor_begin" + currentStruc + ":");
                                            String mitemp1 = "local_data_int " + val.toString();
                                            cod3D.append("\n" + mitemp1);
                                            String mitemp2 = val.toString() + " = " + 0;
                                            cod3D.append("\n" + mitemp2);

                                            currentTemp++;
                                            String mitemp3 = "t" + currentTemp + " = " + elementos1[0];
                                            cod3D.append("\n" + mitemp3);
                                            currentTemp++;
                                            Integer x = currentTemp - 1;
                                            String mitemp4 = "t" + currentTemp + " = " + val.toString() + " < " + "t" + x;
                                            cod3D.append("\n" + mitemp4);
                                            cod3D.append("\nif " + "t" + currentTemp + " goto forBlock" + currentStruc);
                                            cod3D.append("\n" + "goto for_end" + currentStruc);
                                            cod3D.append("\n" + "forBlock" + currentStruc + ":");
                                            RESULT = val.toString() + ":" + elementos1[0];:};

forStrucBegin2 ::= FOR SEP IDENTIFIER:val SEP IN SEP RANGE PARENTS exprP:expr1 COMA exprP:expr2 {:
                                            String[] elementos1 = expr1.toString().split(":");
                                            String[] elementos2 = expr2.toString().split(":");
                                            currentStruc++; 
                                            if(!elementos1[1].equals("INT") || !elementos2[1].equals("INT")) {System.out.println("ERROR SEMANTICO -> Los parametros del range deben ser de tipo entero");System.exit(0);}

                                            cod3D.append("\nfor_begin" + currentStruc + ":");
                                            String mitemp1 = "local_data_int " + val.toString();
                                            cod3D.append("\n" + mitemp1);
                                            String mitemp2 = val.toString() + " = " + elementos1[0];
                                            cod3D.append("\n" + mitemp2);

                                            currentTemp++;
                                            String mitemp3 = "t" + currentTemp + " = " + elementos2[0];
                                            cod3D.append("\n" + mitemp3);
                                            currentTemp++;
                                            Integer x = currentTemp - 1;
                                            String mitemp4 = "t" + currentTemp + " = " + val.toString() + " < " + "t" + x;
                                            cod3D.append("\n" + mitemp4);
                                            cod3D.append("\nif " + "t" + currentTemp + " goto forBlock" + currentStruc);
                                            cod3D.append("\n" + "goto for_end" + currentStruc);
                                            cod3D.append("\n" + "forBlock" + currentStruc + ":");
                                            RESULT = val.toString() + ":" + elementos2[0];:};

forStrucBegin3 ::= FOR SEP IDENTIFIER:val SEP IN SEP RANGE PARENTS exprP:expr1 COMA exprP:expr2 COMA exprP:expr3 PARENTC {:
                                            String[] elementos1 = expr1.toString().split(":");
                                            String[] elementos2 = expr2.toString().split(":");
                                            String[] elementos3 = expr3.toString().split(":");
                                            currentStruc++;
                                            if(!elementos1[1].equals("INT") || !elementos2[1].equals("INT") || !elementos3[1].equals("INT")) {System.out.println("ERROR SEMANTICO -> Los parametros del range deben ser de tipo entero");System.exit(0);} 
                                            
                                            cod3D.append("\nfor_begin" + currentStruc + ":");
                                            String mitemp1 = "local_data_int " + val.toString();
                                            cod3D.append("\n" + mitemp1);
                                            String mitemp2 = val.toString() + " = " + elementos1[0];
                                            cod3D.append("\n" + mitemp2);

                                            currentTemp++;
                                            String mitemp3 = "t" + currentTemp + " = " + elementos2[0];
                                            cod3D.append("\n" + mitemp3);
                                            currentTemp++;
                                            Integer x = currentTemp - 1;
                                            String mitemp4 = "t" + currentTemp + " = " + val.toString() + " < " + "t" + x;
                                            cod3D.append("\n" + mitemp4);
                                            cod3D.append("\nif " + "t" + currentTemp + " goto forBlock" + currentStruc);
                                            cod3D.append("\n" + "goto for_end" + currentStruc);
                                            cod3D.append("\n" + "forBlock" + currentStruc + ":");
                                            RESULT = val.toString() + ":" + elementos2[0] + ":" + elementos3[0];:};

forStruc ::= forStrucBegin2:expr1 PARENTC DELIMETERBLOCK BLOCK DELIMETERBLOCK 
            {: 
                String[] elementos1 = expr1.toString().split(":");
                currentTemp++;
                cod3D.append("\nfor_end_block" + currentStruc + ":");
                String mitemp = "\nt" + currentTemp + " = 1";
                cod3D.append(mitemp);
                String idTemp = elementos1[0].toString();
                cod3D.append("\n" + idTemp + " = t" + currentTemp + " + " + idTemp);
                currentTemp++;
                String mitemp2 = "\nt" + currentTemp + " = " + elementos1[1];
                cod3D.append(mitemp2);
                currentTemp++;
                Integer x = currentTemp - 1;
                String mitemp3 = "\nt" + currentTemp + " = " + idTemp + " < " + "t" + x;
                cod3D.append(mitemp3);
                cod3D.append("\nif " + "t" + currentTemp + " goto forBlock" + currentStruc);
                cod3D.append("\nfor_end" + currentStruc + ":");:}

            | forStrucBegin:expr1 DELIMETERBLOCK BLOCK DELIMETERBLOCK {: 

                String[] elementos1 = expr1.toString().split(":");
                currentTemp++;
                cod3D.append("\nfor_end_block" + currentStruc + ":");
                String mitemp = "\nt" + currentTemp + " = 1";
                cod3D.append(mitemp);
                String idTemp = elementos1[0].toString();
                cod3D.append("\n" + idTemp + " = t" + currentTemp + " + " + idTemp);
                currentTemp++;
                String mitemp2 = "\nt" + currentTemp + " = " + elementos1[1];
                cod3D.append(mitemp2);
                currentTemp++;
                Integer x = currentTemp - 1;
                String mitemp3 = "\nt" + currentTemp + " = " + idTemp + " < " + "t" + x;
                cod3D.append(mitemp3);
                cod3D.append("\nif " + "t" + currentTemp + " goto forBlock" + currentStruc);
                cod3D.append("\nfor_end" + currentStruc + ":");
                :}

            | forStrucBegin3:expr1 DELIMETERBLOCK BLOCK DELIMETERBLOCK {:
                String[] elementos1 = expr1.toString().split(":");
                currentTemp++;
                cod3D.append("\nfor_end_block" + currentStruc + ":");
                String mitemp = "\nt" + currentTemp + " = " + elementos1[2];
                cod3D.append(mitemp);
                String idTemp = elementos1[0].toString();
                cod3D.append("\n" + idTemp + " = t" + currentTemp + " + " + idTemp);
                currentTemp++;
                String mitemp2 = "\nt" + currentTemp + " = " + elementos1[1];
                cod3D.append(mitemp2);
                currentTemp++;
                Integer x = currentTemp - 1;
                String mitemp3 = "\nt" + currentTemp + " = " + idTemp + " < " + "t" + x;
                cod3D.append(mitemp3);
                cod3D.append("\nif " + "t" + currentTemp + " goto forBlock" + currentStruc);
                cod3D.append("\nfor_end" + currentStruc + ":");:};


//Declaracion de parametros
paramStruc ::= PARAM SEP INT SEP IDENTIFIER:ID {:
                                                currentParam++;
                                                cod3D.append("\nparam" + currentParam + " " + ID.toString());
                                                String tipo = getTipo(ID.toString()); RESULT = tipo; scopePrograma.get(currentHash).add("Instancia PARAM: " + ID.toString() + ":" + "INT"); :}

        | PARAM SEP CHAR SEP IDENTIFIER:ID {:
                                                currentParam++;
                                                cod3D.append("\nparam" + currentParam + " " + ID.toString());
                                                String tipo = getTipo(ID.toString()); RESULT = tipo; scopePrograma.get(currentHash).add("Instancia PARAM: " + ID.toString() + ":" + "CHAR"); :}

        | PARAM SEP STRINGT SEP IDENTIFIER:ID {:
                                                currentParam++;
                                                cod3D.append("\nparam" + currentParam + " " + ID.toString());
                                                String tipo = getTipo(ID.toString()); RESULT = tipo; scopePrograma.get(currentHash).add("Instancia PARAM: " + ID.toString() + ":" + "STRING"); :}
        | PARAM SEP FLOAT SEP IDENTIFIER:ID {:
                                                currentParam++;
                                                cod3D.append("\nparam" + currentParam + " " + ID.toString());
                                                String tipo = getTipo(ID.toString()); RESULT = tipo; scopePrograma.get(currentHash).add("Instancia PARAM: " + ID.toString() + ":" + "FLOAT"); :}
        | PARAM SEP BOOL SEP IDENTIFIER:ID  {:
                                                currentParam++;
                                                cod3D.append("\nparam" + currentParam + " " + ID.toString());
                                                String tipo = getTipo(ID.toString()); RESULT = tipo; scopePrograma.get(currentHash).add("Instancia PARAM: " + ID.toString() + ":" + "BOOL"); :}; 

paramList ::= paramStruc paramList
        | paramStruc;


printStruc ::= PRINT PARENTS compAritOp:val PARENTC {: 
                                                String[] elementos = val.toString().split(":");
                                                if (elementos[1].equals("FLOAT")) 
                                                {
                                                    
                                                    //cod3D.append("\nf" + currentFloat + " = " + elementos[0]);
                                                    cod3D.append("\nprint f" + currentFloat);}
                                                else {
                                                    
                                                    //cod3D.append("\nt" + currentTemp + " = " + elementos[0]);
                                                    cod3D.append("\nprint t" + currentTemp);}; :};


returnStruc ::=  RETURN SEP exprP:val ENDEXPR {:
                                                String[] elementos = val.toString().split(":");
                                                boolean valido = validarReturn(elementos[1]); 
                                                if (elementos[1].equals("FLOAT")) {cod3D.append("\nreturn f" + currentFloat);}
                                                else {cod3D.append("\nreturn t" + currentTemp);};
                                                currentReturns++;

                                                if (!valido) {System.out.println("ERROR RETORNO -> Tipo de retorno distinto al de la funcion");System.exit(0);}:}
        | RETURN ENDEXPR;

