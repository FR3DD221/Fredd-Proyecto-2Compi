package proye1_compi;
import java_cup.runtime.*;
import java.util.HashMap; 
import java.util.List;
import java.util.ArrayList;

parser code {:
    // Connect this parser to a scanner!
    Lexer lex;
    HashMap<String, ArrayList<String>> scopePrograma = new HashMap<String, ArrayList<String>>();
    String currentHash;
    String globalHash = "SCOPE GLOBAL";

    @SuppressWarnings("deprecation")
    public Parser(Lexer lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }

    public boolean existeVar(String ID, String tipo) {
        ArrayList<String> ts = scopePrograma.get(currentHash);
        String comparado = "Instancia loc: " + ID.toString() + ":" + tipo;

        for (String variable : ts) {
            if (variable.equals(comparado)) {return true;}
        }

        return false;
    }

    public boolean existeVarNoT(String ID) {
        ArrayList<String> ts = scopePrograma.get(currentHash);
        ArrayList<String> ts2 = scopePrograma.get(globalHash);
        
        for (String variable : ts) {
            String[] elementosVar = variable.split(":");
            
            if (elementosVar[1].trim().equals(ID)) {return true;}
        }
        for (String variable2 : ts2) {
            String[] elementosVar2 = variable2.split(":");
            
            if (elementosVar2[1].trim().equals(ID)) {return true;}
        }

        return false;
    }

    public String getTipo(String ID) {
        ArrayList<String> ts = scopePrograma.get(currentHash);
        ArrayList<String> ts2 = scopePrograma.get(globalHash);

        for (String variable : ts) {
            String[] elementosVar = variable.split(":");
            if (elementosVar[1].trim().equals(ID)) {return elementosVar[2];}
        }

        for (String variable : ts2) {
            String[] elementosVar = variable.split(":");
            if (elementosVar[1].trim().equals(ID)) {return elementosVar[2];}
        }

        return "null";
    }

    public String getTipoFunc(String ID) {
        for (String key : scopePrograma.keySet()) {
            ArrayList<String> value = scopePrograma.get(key);
            for (String elemento : value) {
                String[] ts = elemento.split(":");
                if (ID.equals(key)) {
                    return ts[2];
                }
            }
        } 

        return "null";
    }

    public boolean existeVarGlob(String ID, String tipo) {
        ArrayList<String> ts = scopePrograma.get(globalHash);
        String comparado = "Instancia GLOB: " + ID.toString() + ":" + tipo;
        
        for (String variable : ts) {
            if (variable.equals(comparado)) {return true;}
        }

        return false;
    }

    public boolean validarReturn(String tipo) {
        ArrayList<String> ts = scopePrograma.get(currentHash);
        
        String[] elementos = ts.get(0).split(":");
        String elemento = elementos[2];
        if (!tipo.equals(elemento)) {return false;}

        return true;
    }

    public boolean existeFun(String ID, String tipo) {
        for (String key : scopePrograma.keySet()) {
            ArrayList<String> value = scopePrograma.get(key);
            for (String elemento : value) {
                String[] ts = elemento.split(":");
                if (ts.length >= 3 && ts[1].equals("func") && ts[2].equals(tipo) && ID.equals(key)) {
                    return true;
                }
            }
        } 

        return false;
    }

    public void imprimirscopePrograma () {
        System.out.println("\nTABLA DE SIMBOLOS");
        for (String key: scopePrograma.keySet()) {
            System.out.println("\n" + key);
            System.out.println("Valores: ");
            for (String item : scopePrograma.get(key)) {
                System.out.println(item);
            }
            System.out.println("");
        }
    }

    public boolean existeArrGlob(String ID, String tipo) {
        ArrayList<String> ts = scopePrograma.get(globalHash);
        String comparado = "Instancia GLOB ARR: " + ID.toString() + ":" + tipo;
        
        for (String variable : ts) {
            if (variable.equals(comparado)) {return true;}
        }

        return false;
    }

    public boolean todosIguales(ArrayList<String> lista) {
        String primerElemento = lista.get(0);
        for (int i = 1; i < lista.size(); i++) {
            if (!lista.get(i).equals(primerElemento)) {
                return false; 
            }
        }

        return true; 
    }

    public boolean existeArr(String ID, String tipo) {
        ArrayList<String> ts = scopePrograma.get(currentHash);
        String comparado = "Instancia LOC ARR: " + ID.toString() + ":" + tipo;

        for (String variable : ts) {

            if (variable.equals(comparado)) {return true;}
        }

        return false;
    }

    public int countParam (String nombreFunc) {
        ArrayList<String> currentFunc = scopePrograma.get(nombreFunc);
        int cantParam = 0;

        for (String elem : currentFunc) {
            String[] expresion = elem.split(":");
            String lexema = expresion[0].trim();
            
            
            if(lexema.equals("Instancia PARAM") ){ cantParam++;}
        }
        return cantParam;
    }

    //recuperacion de errores de sintaxis
    public void syntax_error(Symbol s) {
        System.out.println("!!Error de Sintaxis en : " +  s.value + " linea: " +  (s.left+1) +  " columna: " +  (s.right+1));
    }

    //manejo de errores fatales
    public void unrecovered_syntax_error(Symbol s) {
        System.out.println("!!Error fatal en : " +  s.value + " linea: " +  (s.left+1) +  " columna: " +  (s.right+1));
    } 

    StringBuffer cod3D = new StringBuffer();
    Integer currentTemp = 0;
    Integer currentFloat = 0;
    Integer stackPointer = 0;
    Integer cantParams = 0;
    ArrayList<String> elementosArray = new ArrayList<>();
:}

/* define how to connect to the scanner! */
//init with {: s.init(); :};
//scan with {: return s.next_token(); :};
init with {::};
scan with {:return lex.next_token();:};


/* Terminales (tokens returned by the scanner). */
terminal            IDENTIFIER, SEMI, PLUS, MINUS, DMINUS, DPLUS, MINUSW, TIMES, UMINUS, PRODUCT, DIVISION, POWER, MODULUS, LPAREN, RPAREN, INTEGER_LITERAL;
terminal Integer    NUMBER;        // our scanner provides numbers as integers
terminal            DELIMETERBLOCK, ASIGNINTSARRAY, ASIGNCHARSARRAY, CHARSTR, INT, CHAR, FLOAT, BOOL, STRINGT, FUNC, MAIN, PARAM, COMA, STRING_LITERAL, EQEQ, BREAK, BOOLEAN, ABSTRACT, EQ, DOT;
terminal            DIFF, NEGATION, GRATHER, GRATHERT, LOWER, LOWERT, COMPARATION, AND, OR, SEP;
terminal            FLOATNUM;
terminal            TRUE, FALSE;
terminal            IF, ELSE, WHILE, FOR, IN, RANGE, SWITCH, CASE, ARRAY;
terminal            LOC, GLOB, BRAKE, DEFAULT, RETURN, PRINT, INPUT;
terminal            PARENTS, PARENTC, SQUARES, SQUAREC;
terminal            ENDEXPR;

/* No terminales */
non terminal            expr_list;
non terminal            Integer expr;// used to store evaluated subexpressions
non terminal            SI, varIns, varAsig, BLOCK, compAritOp, factor, term, funcStruc, mainStruc, types, printStruc;
non terminal            ifStruc, ifElseStruc, whileStruc, arrayIns, arrayAsig, arrayInsAsign, elementos, switchStruc, caseStruc, forStruc, numbers;
non terminal            returnStruc, inputStruc, mainInitial, funInitial, exprP, exprLog, exprUni, opRel, opLog, arrayElement, paramStruc, paramList, paramFunc, funcInvo, GEN, arrayInsGl, varInsGl, varInsAsig, varInsAsigGl, arrayInsAsignGl;

/* Orden de precedencia */
precedence left PLUS, MINUSW;
precedence left PRODUCT;
precedence left DIVISION;

/* The grammar rules */    

start with SI;

SI ::= {: scopePrograma.put(globalHash, new ArrayList<String>()); :} 
    GEN {: System.out.println(cod3D.toString()); :};//{: imprimirscopePrograma(); :}

GEN ::= funcStruc GEN | mainStruc GEN | arrayInsGl ENDEXPR GEN | varInsGl ENDEXPR GEN | varInsAsigGl 
    | varInsAsigGl GEN | funcStruc | mainStruc | arrayInsGl ENDEXPR | varInsGl ENDEXPR | error | error GEN
    | arrayInsAsignGl GEN | arrayInsAsignGl;  

//Los distintos tipos que pueden tener una funcion o variable

//Bloque que se usa para el codigo siga un rumbo, vease como la lista de posibles expresiones
BLOCK ::= BLOCK exprP ENDEXPR
        | BLOCK varAsig 
        | BLOCK arrayInsGl ENDEXPR
        | BLOCK varInsGl ENDEXPR
        | BLOCK varInsAsigGl
        | BLOCK arrayInsAsignGl
        | BLOCK mainStruc
        | BLOCK funcStruc 
        | BLOCK varIns ENDEXPR
        | BLOCK ifStruc 
        | BLOCK ifElseStruc 
        | BLOCK whileStruc 
        | BLOCK switchStruc 
        | BLOCK forStruc 
        | BLOCK arrayIns ENDEXPR
        | BLOCK varInsAsig 
        | BLOCK arrayInsAsign
        | BLOCK printStruc ENDEXPR
        | BLOCK BREAK ENDEXPR
        | BLOCK inputStruc
        | BLOCK arrayAsig
        | BLOCK returnStruc
        | exprP ENDEXPR
        | arrayIns ENDEXPR
        | arrayInsAsign
        | mainStruc 
        | funcStruc 
        | varAsig    
        | arrayInsGl ENDEXPR
        | varInsGl ENDEXPR
        | varInsAsigGl
        | arrayInsAsignGl
        | varInsAsig 
        | varIns ENDEXPR
        | ifStruc 
        | ifElseStruc
        | switchStruc
        | forStruc
        | arrayAsig
        | whileStruc
        | returnStruc
        | printStruc ENDEXPR
        | BREAK ENDEXPR
        | inputStruc
        | error;


numbers ::= INTEGER_LITERAL:lit {: RESULT = lit + ":" + "INT";:}
        | FLOATNUM:lit {:RESULT = lit + ":" + "FLOAT";:};

//Operaciones aritmeticas simples entre dos numeros
/* Reglas de producción para operaciones aritméticas */
compAritOp ::= term:op2 {:RESULT = op2;:}
             //| compAritOp MINPLS term  {: System.out.println("Se hizo MULTIPLESIMB"); :}
                | compAritOp:op1 PLUS term:op2  {: 
                                                String[] elementos1 = op1.toString().split(":");
                                                String[] elementos2 = op2.toString().split(":");
                                                if(!elementos1[1].equals(elementos2[1])) {System.out.println("Error semantico, en esta suma los operadores deben ser del mismo tipo");} else 
                                                {String baseTemp = "t";
                                                    String miTempId;

                                                    if (elementos1[1].equals("FLOAT")) {
                                                        baseTemp = "f";
                                                        currentFloat++;
                                                        miTempId = baseTemp + currentFloat;}
                                                    else {
                                                        currentTemp++;
                                                        miTempId = baseTemp + currentTemp;}
                                                    
                                                    cod3D.append("\n" + miTempId + "=" + elementos1[0] + "+" + elementos2[0]);

                                                    RESULT = miTempId + ":" + elementos1[1];}:}
                | compAritOp:op1 MINUSW term:op2  {: 
                                                String[] elementos1 = op1.toString().split(":");
                                                String[] elementos2 = op2.toString().split(":");
                                                if(!elementos1[1].equals(elementos2[1])) {System.out.println("Error semantico, en esta resta los operadores deben ser del mismo tipo");} 
                                                else {
                                                    String baseTemp = "t";
                                                    String miTempId;

                                                    if (elementos1[1].equals("FLOAT")) {
                                                        baseTemp = "f";
                                                        currentFloat++;
                                                        miTempId = baseTemp + currentFloat;}
                                                    else {
                                                        currentTemp++;
                                                        miTempId = baseTemp + currentTemp;}
                                                    
                                                    cod3D.append("\n" + miTempId + "=" + elementos1[0] + "-" + elementos2[0]);

                                                    RESULT = miTempId + ":" + elementos1[1];}:};

term       ::= factor:op2 {:RESULT = op2;:}
                | term:op1 PRODUCT factor:op2  {: 
                                                String[] elementos1 = op1.toString().split(":");
                                                String[] elementos2 = op2.toString().split(":");
                                                if(!elementos1[1].equals(elementos2[1])) {System.out.println("Error semantico, en este producto los operadores deben ser del mismo tipo");} else 
                                                {String baseTemp = "t";
                                                    String miTempId;

                                                    if (elementos1[1].equals("FLOAT")) {
                                                        baseTemp = "f";
                                                        currentFloat++;
                                                        miTempId = baseTemp + currentFloat;}
                                                    else {
                                                        currentTemp++;
                                                        miTempId = baseTemp + currentTemp;}
                                                    
                                                    cod3D.append("\n" + miTempId + "=" + elementos1[0] + "*" + elementos2[0]);

                                                    RESULT = miTempId + ":" + elementos1[1];}:}
                | term:op1 DIVISION factor:op2  {: 
                                                String[] elementos1 = op1.toString().split(":");
                                                String[] elementos2 = op2.toString().split(":");
                                                if(!elementos1[1].equals(elementos2[1])) {System.out.println("Error semantico, en este cociente los operadores deben ser del mismo tipo");} 
                                                else {String baseTemp = "t";
                                                    String miTempId;

                                                    if (elementos1[1].equals("FLOAT")) {
                                                        baseTemp = "f";
                                                        currentFloat++;
                                                        miTempId = baseTemp + currentFloat;}
                                                    else {
                                                        currentTemp++;
                                                        miTempId = baseTemp + currentTemp;}
                                                    
                                                    cod3D.append("\n" + miTempId + "=" + elementos1[0] + "/" + elementos2[0]);

                                                    RESULT = miTempId + ":" + elementos1[1];}:}
                | term:op1 POWER factor:op2   {: 
                                                String[] elementos1 = op1.toString().split(":");
                                                String[] elementos2 = op2.toString().split(":");
                                                if(!elementos1[1].equals(elementos2[1])) {System.out.println("Error semantico, en esta potencia los operadores deben ser del mismo tipo");} else 
                                                {String baseTemp = "t";
                                                    String miTempId;

                                                    if (elementos1[1].equals("FLOAT")) {
                                                        baseTemp = "f";
                                                        currentFloat++;
                                                        miTempId = baseTemp + currentFloat;}
                                                    else {
                                                        currentTemp++;
                                                        miTempId = baseTemp + currentTemp;}
                                                    
                                                    cod3D.append("\n" + miTempId + "=" + elementos1[0] + "^" + elementos2[0]);

                                                    RESULT = miTempId + ":" + elementos1[1];}:}  
                | term:op1 MODULUS factor:op2   {: 
                                                String[] elementos1 = op1.toString().split(":");
                                                String[] elementos2 = op2.toString().split(":");
                                                if(!elementos1[1].equals(elementos2[1])) {System.out.println("Error semantico, en este modulo los operadores deben ser del mismo tipo");} else 
                                                {String baseTemp = "t";
                                                    String miTempId;

                                                    if (elementos1[1].equals("FLOAT")) {
                                                        baseTemp = "f";
                                                        currentFloat++;
                                                        miTempId = baseTemp + currentFloat;}
                                                    else {
                                                        currentTemp++;
                                                        miTempId = baseTemp + currentTemp;}
                                                    
                                                    cod3D.append("\n" + miTempId + "=" + elementos1[0] + "%" + elementos2[0]);

                                                    RESULT = miTempId + ":" + elementos1[1];}:};

factor     ::= numbers:numero {:
                String[] elementos = numero.toString().split(":");
                if (elementos[1].equals("FLOAT")) {   
                    currentFloat++;             
                    String miTempId = "f"+currentFloat;
                    cod3D.append("\n" +  miTempId + "=" + elementos[0]);}
                else {    
                    currentTemp++;            
                    String miTempId = "t"+currentTemp;
                    cod3D.append("\n" +  miTempId + "=" + elementos[0]);}

                RESULT = numero;:}

                | MINUSW numbers:numero {:RESULT = numero;:}
                | STRING_LITERAL:lit {:
                                currentTemp++;
                                String miTempId = "t"+currentTemp;
                                cod3D.append("\n" +  miTempId + "=" + lit.toString());
                                RESULT = miTempId.trim() + ":STRING";:}

                | CHARSTR:lit {:
                        currentTemp++;
                        String miTempId = "t"+currentTemp;
                        cod3D.append("\n" +  miTempId + "=" + lit.toString());
                        RESULT = miTempId.trim() + ":CHAR";:}

                | IDENTIFIER:ID {:
                                String tipo = getTipo(ID.toString()); 
                                String baseTemp = "t";
                                String miTempId;
                                if (tipo.equals("FLOAT")) {
                                    baseTemp = "f";
                                    currentFloat++;
                                    miTempId = baseTemp + currentFloat;}
                                else {
                                    currentTemp++;
                                    miTempId = baseTemp + currentTemp;}

                                cod3D.append("\n" + miTempId + "=" + ID.toString());

                                RESULT = miTempId.trim() + ":" + tipo;:}

                | IDENTIFIER:ID DMINUS {:String tipo = getTipo(ID.toString()); 
                                        String baseTemp = "t";
                                        String miTempId;
                                        if (tipo.equals("FLOAT")) {
                                            baseTemp = "f";
                                            currentFloat++;
                                            miTempId = baseTemp + currentFloat;}
                                        else {
                                            currentTemp++;
                                            miTempId = baseTemp + currentTemp;}
                                        cod3D.append("\n" + miTempId + "=" + ID.toString());
                                        currentTemp++;
                                        String miTemp1 = baseTemp + currentTemp;
                                        currentTemp++;
                                        String miTemp2 = baseTemp + currentTemp;

                                        cod3D.append("\n" + miTemp1 + " = 1");
                                        cod3D.append("\n" + miTemp2 + " = " + miTempId + "-" + miTemp1);
                                        cod3D.append("\n" + ID.toString() + " = " + miTemp2);
                                        
                                        RESULT = ID.toString().trim() + ":" + tipo;:} 

                | IDENTIFIER:ID DPLUS {:String tipo = getTipo(ID.toString()); 
                                        String baseTemp = "t";
                                        String miTempId;
                                        if (tipo.equals("FLOAT")) {
                                            baseTemp = "f";
                                            currentFloat++;
                                            miTempId = baseTemp + currentFloat;}
                                        else {
                                            currentTemp++;
                                            miTempId = baseTemp + currentTemp;}
                                        cod3D.append("\n" + miTempId + "=" + ID.toString());
                                        currentTemp++;
                                        String miTemp1 = baseTemp + currentTemp;
                                        currentTemp++;
                                        String miTemp2 = baseTemp + currentTemp;

                                        cod3D.append("\n" + miTemp1 + " = 1");
                                        cod3D.append("\n" + miTemp2 + " = " + miTempId + "+" + miTemp1);
                                        cod3D.append("\n" + ID.toString() + " = " + miTemp2);
                                        
                                        RESULT = ID.toString().trim() + ":" + tipo;:}

                | arrayElement:arrE {:RESULT = arrE;:}
                | paramList:pLis {:RESULT = pLis;:}
                | funcInvo:funI {:RESULT = funI;:}
                | MINUSW PARENTS compAritOp:comp PARENTC {:RESULT = comp;:}
                | PARENTS compAritOp:comp PARENTC {:RESULT = comp;:};  


inputStruc ::= INPUT PARENTS IDENTIFIER PARENTC ENDEXPR;


//Manejo de distintas expresiones de comparacion y union
exprP ::= exprLog:expL {:RESULT = expL;:} 
        | compAritOp:comp {:RESULT = comp;:}      
        | exprUni:expU {:RESULT = expU;:} ;

exprLog ::= compAritOp:op1 opRel:op compAritOp:op2 {: 
                                                    String[] elementos1 = op1.toString().split(":");
                                                    String[] elementos2 = op2.toString().split(":");
                                                    System.out.println(elementos2[1]);

                                                    if(!elementos1[1].equals(elementos2[1])) {System.out.println("Error, la comparacion debe ser entre valores del mismo tipo"); RESULT = elementos1[0] + ":" + "NULL";} else 
                                                    {
                                                    String baseTemp = "t";
                                                    currentTemp++;
                                                    String miTempId = baseTemp + currentTemp + " = " + elementos1[0];
                                                    currentTemp++;
                                                    cod3D.append("\n" + miTempId);
                                                    String miTempId2 = baseTemp + currentTemp + " = " + elementos2[0];
                                                    int x = currentTemp - 2;
                                                    int y = x + 1;
                                                    cod3D.append("\n" + miTempId2);
                                                    currentTemp++;
                                                    String miTempId3 = baseTemp + currentTemp + " = t" + y + op.toString() + "t" + x;
                                                    cod3D.append("\n" + miTempId3);

                                                    RESULT = baseTemp + currentTemp + ":" + "BOOL";} :}
        | PARENTS exprLog:op2 PARENTC {:RESULT = op2;:}
        | opRel exprLog:op2 {:RESULT = op2;:}
        | TRUE {:RESULT = "TRUE:BOOL";:} 
        | FALSE {:RESULT = "FALSE:BOOL";:};

exprUni ::= exprLog:op1 opLog:op exprP:op2  {: String[] elementos1 = op1.toString().split(":");
                                            String[] elementos2 = op2.toString().split(":");
                                            System.out.println(op2);
                                            if(elementos1[1].equals("BOOL") && elementos2[1].equals("BOOL")) 
                                            {
                                                String baseTemp = "t";
                                                currentTemp++;
                                                String miTempId = baseTemp + currentTemp + " = " + elementos1[0];
                                                currentTemp++;
                                                cod3D.append("\n" + miTempId);
                                                String miTempId2 = baseTemp + currentTemp + " = " + elementos2[0];
                                                int x = currentTemp - 2;
                                                int y = x + 1;
                                                cod3D.append("\n" + miTempId2);
                                                currentTemp++;
                                                String miTempId3 = baseTemp + currentTemp + " = t" + y + op.toString() + "t" + x;
                                                cod3D.append("\n" + miTempId3);

                                                RESULT = baseTemp + currentTemp + ":" + "BOOL";} 

                                            else {System.out.println("Ambos operadores deben ser booleanos"); RESULT = elementos1[0] + ":" + "NULL";}:}
        | IDENTIFIER:ID opLog:op exprP:op2  {: 
                                            String tipo = getTipo(ID.toString());
                                            String[] elementos1 = op2.toString().split(":");
                                            
                                            if(tipo.equals("BOOL") && elementos1[1].equals("BOOL")) 
                                            {
                                                
                                                String baseTemp = "t";
                                                currentTemp++;
                                                String miTempId = baseTemp + currentTemp + " = " + elementos1[0];
                                                cod3D.append("\n" + miTempId);
                                                currentTemp++;
                                                String miTempId2 = baseTemp + currentTemp + " = " + ID.toString();
                                                int x = currentTemp - 2;
                                                int y = x + 1;
                                                cod3D.append("\n" + miTempId2);
                                                currentTemp++;
                                                String miTempId3 = baseTemp + currentTemp + " = t" + y + op.toString() + "t" + x;

                                                cod3D.append("\n" + miTempId3);

                                                RESULT = baseTemp + currentTemp + ":" + "BOOL";} 
                                            else {System.out.println("Ambos operadores deben ser booleanos"); RESULT = elementos1[0] + ":" + "NULL";} :}
        | PARENTS exprUni PARENTC;

opRel ::= GRATHER {:RESULT = ">";:} | GRATHERT {:RESULT = ">=";:}  | LOWER {:RESULT = "<";:}  | LOWERT {:RESULT = "<=";:}  | DIFF {:RESULT = "!=";:}  | COMPARATION {:RESULT = "==";:}  | NEGATION {:RESULT = "!";:} ;
opLog ::= AND {:RESULT = "&&";:} 
        | OR {:RESULT = "||";:};

//Asignación de un valor a una variable
varAsig      ::=  IDENTIFIER:ID EQ exprP:val ENDEXPR  {: 
                                                    String tipo = getTipo(ID.toString());
                                                    boolean existe = existeVar(ID.toString(), tipo);
                                                    boolean existe2 = existeVarGlob(ID.toString(), tipo);
                                                    if (!existe && !existe2) {System.out.println("Esta variable -> " + ID.toString() + " <- no existe");}
                                                    String[] valores = val.toString().split(":");
                                                    
                                                    if(!tipo.equals(valores[1])) {System.out.println("Error semantico, el tipo de la variable no coincide con el asignado");} else {RESULT = tipo;}:}
                | EQ exprP:val ENDEXPR {:RESULT = val;:};


//Instanciacion simple de variables
varIns       ::= LOC SEP INT SEP IDENTIFIER:ID    {:
                                                    boolean existe = existeVar(ID.toString(), "INT");
                                                    if (existe) {System.out.println("La variable local -> " + ID.toString() + " <- ya fue declarada");}  
                                                    scopePrograma.get(currentHash).add("Instancia loc: " + ID.toString() + ":" + "INT");  

                                                    cod3D.append("\nlocal_data_int " + ID.toString());

                                                    RESULT = "INT";:}
                | LOC SEP CHAR SEP IDENTIFIER:ID     {: 
                                                    boolean existe = existeVar(ID.toString(), "CHAR");
                                                    if (existe) {System.out.println("La variable local -> " + ID.toString() + " <- ya fue declarada");}  
                                                    scopePrograma.get(currentHash).add("Instancia loc: " + ID.toString() + ":" + "CHAR");  

                                                    cod3D.append("\nlocal_data_char " + ID.toString());

                                                    RESULT = "CHAR";:}   
                | LOC SEP FLOAT SEP IDENTIFIER:ID    {: 
                                                    boolean existe = existeVar(ID.toString(), "FLOAT");
                                                    if (existe) {System.out.println("La variable local -> " + ID.toString() + " <- ya fue declarada");} 
                                                    scopePrograma.get(currentHash).add("Instancia loc: " + ID.toString() + ":" + "FLOAT");  

                                                    cod3D.append("\nlocal_data_float " + ID.toString());

                                                    RESULT = "FLOAT";:}
                | LOC SEP BOOL SEP IDENTIFIER:ID     {: 
                                                    boolean existe = existeVar(ID.toString(), "BOOL");
                                                    if (existe) {System.out.println("La variable local -> " + ID.toString() + " <- ya fue declarada");}  
                                                    scopePrograma.get(currentHash).add("Instancia loc: " + ID.toString() + ":" + "BOOL");  

                                                    cod3D.append("\nlocal_data_bool " + ID.toString());

                                                    RESULT = "BOOL";:}  
                | LOC SEP STRINGT SEP IDENTIFIER:ID  {: 
                                                    boolean existe = existeVar(ID.toString(), "STRING");
                                                    if (existe) {System.out.println("La variable local -> " + ID.toString() + " <- ya fue declarada");} 
                                                    scopePrograma.get(currentHash).add("Instancia loc: " + ID.toString() + ":" + "STRING"); 

                                                    cod3D.append("\nlocal_data_string " + ID.toString());

                                                    RESULT = "STRING";:};



varInsGl     ::=  GLOB SEP INT SEP IDENTIFIER:ID     {: 
                                                        boolean existe = existeVarGlob(ID.toString(), "INT");
                                                        if (existe) {System.out.println("La variable global -> " + ID.toString() + " <- ya fue declarada");}
                                                        scopePrograma.get(globalHash).add("Instancia GLOB: " + ID.toString() + ":" + "INT"); 

                                                        cod3D.append("\nglobal_data_int " + ID.toString());

                                                        RESULT = "INT";:}
                | GLOB SEP CHAR SEP IDENTIFIER:ID       {:          
                                                        boolean existe = existeVarGlob(ID.toString(), "CHAR");
                                                        if (existe) {System.out.println("La variable global -> " + ID.toString() + " <- ya fue declarada");} 
                                                        scopePrograma.get(globalHash).add("Instancia GLOB: " + ID.toString() + ":" + "CHAR");

                                                        cod3D.append("\nglobal_data_char " + ID.toString());

                                                        RESULT = "CHAR";:}
                | GLOB SEP FLOAT SEP IDENTIFIER:ID      {:
                                                        boolean existe = existeVarGlob(ID.toString(), "FLOAT");
                                                        if (existe) {System.out.println("La variable global -> " + ID.toString() + " <- ya fue declarada");}
                                                        scopePrograma.get(globalHash).add("Instancia GLOB: " + ID.toString() + ":" + "FLOAT"); 

                                                        cod3D.append("\nglobal_data_float " + ID.toString());

                                                        RESULT = "FLOAT";:}
                | GLOB SEP STRINGT SEP IDENTIFIER:ID    {:
                                                        boolean existe = existeVarGlob(ID.toString(), "STRING");
                                                        if (existe) {System.out.println("La variable global -> " + ID.toString() + " <- ya fue declarada");}
                                                        scopePrograma.get(globalHash).add("Instancia GLOB: " + ID.toString() + ":" + "STRING"); 

                                                        cod3D.append("\nglobal_data_string " + ID.toString());

                                                        RESULT = "STRING";:}
                | GLOB SEP BOOL SEP IDENTIFIER:ID       {: 
                                                        boolean existe = existeVarGlob(ID.toString(), "BOOL");
                                                        if (existe) {System.out.println("La variable global -> " + ID.toString() + " <- ya fue declarada");}
                                                        scopePrograma.get(globalHash).add("Instancia GLOB: " + ID.toString() + ":" + "BOOL"); 

                                                        cod3D.append("\nglobal_data_bool " + ID.toString());

                                                        RESULT = "BOOL";:};

varInsAsig   ::= varIns:t1 varAsig:t2 {:if (!t1.equals(t2)) {System.out.println("ERROR VAR LOCAL-> El tipo de variable no coincide con el asignado");}:};
varInsAsigGl   ::= varInsGl:t1 varAsig:t2 {:if (!t1.equals(t2)) {System.out.println("ERROR VAR GLOB-> El tipo de variable no coincide con el asignado");}:};

funInitial   ::= FUNC SEP INT SEP IDENTIFIER:ID
                        {:   String tipo;
                                                            boolean existe = existeFun(ID.toString(), "INT");
                                                            if (existe) {System.out.println("La funcion -> " + ID.toString() + " <- ya fue declarada");} 
                                                            tipo = "tipo:func:INT";
                                                            ArrayList<String> fun = new ArrayList<String>();
                                                            currentHash = ID.toString();
                                                            fun.add(tipo);
                                                            scopePrograma.put(currentHash, fun);

                                                            cod3D.append("\n\nbegin_func_" + ID.toString()+":");
                                                            currentTemp = 0;
                                                            currentFloat = 0;

                                                            RESULT = "INT";
                        :}
                | FUNC SEP CHAR SEP IDENTIFIER:ID
                        {:   String tipo;
                                                            boolean existe = existeFun(ID.toString(), "CHAR");
                                                            if (existe) {System.out.println("La funcion -> " + ID.toString() + " <- ya fue declarada");} 
                                                            tipo = "tipo:func:CHAR";
                                                            ArrayList<String> fun = new ArrayList<String>();
                                                            currentHash = ID.toString();
                                                            fun.add(tipo);
                                                            scopePrograma.put(currentHash, fun);

                                                            cod3D.append("\n\nbegin_func_" + ID.toString()+":");
                                                            currentTemp = 0;
                                                            currentFloat = 0;

                                                            RESULT = "CHAR";
                        :}
                | FUNC SEP BOOL SEP IDENTIFIER:ID
                        {:   String tipo;
                                                            boolean existe = existeFun(ID.toString(), "BOOL");
                                                            if (existe) {System.out.println("La funcion -> " + ID.toString() + " <- ya fue declarada");} 
                                                            tipo = "tipo:func:BOOL";
                                                            ArrayList<String> fun = new ArrayList<String>();
                                                            currentHash = ID.toString();
                                                            fun.add(tipo);
                                                            scopePrograma.put(currentHash, fun);

                                                            cod3D.append("\n\nbegin_func_" + ID.toString()+":");
                                                            currentTemp = 0;
                                                            currentFloat = 0;

                                                            RESULT = "BOOL";
                        :}
                | FUNC SEP STRINGT SEP IDENTIFIER:ID
                        {:   String tipo;
                                                            boolean existe = existeFun(ID.toString(), "STRING");
                                                            if (existe) {System.out.println("La funcion -> " + ID.toString() + " <- ya fue declarada");} 
                                                            tipo = "tipo:func:STRING";
                                                            ArrayList<String> fun = new ArrayList<String>();
                                                            currentHash = ID.toString();
                                                            fun.add(tipo);
                                                            scopePrograma.put(currentHash, fun);

                                                            cod3D.append("\n\nbegin_func_" + ID.toString()+":");
                                                            currentTemp = 0;
                                                            currentFloat = 0;

                                                            RESULT = "STRING";
                        :}
                | FUNC SEP FLOAT SEP IDENTIFIER:ID
                        {:   String tipo;
                                                            boolean existe = existeFun(ID.toString(), "FLOAT");
                                                            if (existe) {System.out.println("La funcion -> " + ID.toString() + " <- ya fue declarada");} 
                                                            tipo = "tipo:func:FLOAT";
                                                            ArrayList<String> fun = new ArrayList<String>();
                                                            currentHash = ID.toString();
                                                            fun.add(tipo);
                                                            scopePrograma.put(currentHash, fun);

                                                            cod3D.append("\n\nbegin_func_" + ID.toString()+":");
                                                            currentTemp = 0;
                                                            currentFloat = 0;

                                                            RESULT = "FLOAT";
                        :};

//Declaracion inicial del bloque para las funciones
funcStruc    ::= funInitial DELIMETERBLOCK BLOCK DELIMETERBLOCK;  

mainInitial  ::= FUNC SEP INT SEP MAIN 
                        {:                              
                                                        if (scopePrograma.get("MAIN") != null) {System.out.println("Ya existe una funcion main");}
                                                        String tipo;
                                                        tipo = "tipo:MAIN:INT";
                                                        ArrayList<String> fun = new ArrayList<String>();
                                                        currentHash = "MAIN";
                                                        fun.add(tipo);

                                                        cod3D.append("\nbegin_main_:");
                                                        currentTemp = 0;
                                                        currentFloat = 0;

                                                        scopePrograma.put(currentHash, fun);
                            :};

mainStruc    ::= mainInitial DELIMETERBLOCK BLOCK DELIMETERBLOCK;

paramFunc    ::= exprP COMA paramFunc {: cantParams++; :}
                | exprP {: cantParams++; :};

funcInvo     ::= IDENTIFIER:ID PARENTS paramFunc PARENTC {: 
                                                            currentTemp++;
                                                            cod3D.append("\nt" + currentTemp + "= call " + ID.toString() + ", " + cantParams);
                                                            cantParams = 0;
                                                            String tipo = getTipoFunc(ID.toString()); 
                                                            boolean existe = existeFun(ID.toString(), tipo);
                                                            if (!existe) {System.out.println("ERROR -> La funcion llamada no ha sido declarada");}
                                                            RESULT = tipo; :}

                | IDENTIFIER:ID PARENTS PARENTC {: String tipo = getTipoFunc(ID.toString()); 
                                                            currentTemp++;
                                                            cod3D.append("\nt" + currentTemp + "= call " + ID.toString() + ", " + 0);
                                                            boolean existe = existeFun(ID.toString(), tipo);
                                                            if (!existe) {System.out.println("ERROR -> La funcion llamada no ha sido declarada");}
                                                            RESULT = tipo; :};



ifStruc      ::= IF PARENTS exprP PARENTC DELIMETERBLOCK BLOCK DELIMETERBLOCK   {:System.out.println("Se declaro estructura condicional IF");:};
ifElseStruc  ::= ifStruc ELSE DELIMETERBLOCK BLOCK DELIMETERBLOCK;


//Produccion while
whileStruc   ::= WHILE PARENTS exprP PARENTC DELIMETERBLOCK BLOCK DELIMETERBLOCK   {:System.out.println("Se declaro el ciclo while");:};

//Declaracion, asignacion y acceso a un array
arrayIns ::=  LOC SEP INT SEP ARRAY SEP IDENTIFIER:ID SQUARES INTEGER_LITERAL SQUAREC {: 
                                                                                        boolean existe = existeArr(ID.toString(), "INT");
                                                                                        if (existe) {System.out.println("El array local -> " + ID.toString() + " <- ya fue declarado");}  
                                                                                        scopePrograma.get(currentHash).add("Instancia LOC ARR: " + ID.toString() + ":" + "INT"); 
                                                                                        RESULT = "INT";:}
            | LOC SEP CHAR SEP ARRAY SEP IDENTIFIER:ID SQUARES INTEGER_LITERAL SQUAREC {: 
                                                                                        boolean existe = existeArr(ID.toString(), "CHAR");
                                                                                        if (existe) {System.out.println("El array local -> " + ID.toString() + " <- ya fue declarado");}
                                                                                        scopePrograma.get(currentHash).add("Instancia LOC ARR: " + ID.toString() + ":" + "CHAR"); 
                                                                                        RESULT = "CHAR";:};

arrayInsGl ::=  GLOB SEP INT SEP ARRAY SEP IDENTIFIER:ID SQUARES INTEGER_LITERAL SQUAREC  {: 
                                                                                        boolean existe = existeArrGlob(ID.toString(), "INT");
                                                                                        if (existe) {System.out.println("El array global -> " + ID.toString() + " <- ya fue declarado");}
                                                                                        scopePrograma.get(globalHash).add("Instancia GLOB ARR: " + ID.toString() + ":" + "INT"); 
                                                                                        RESULT = "INT";:}
            | GLOB SEP CHAR SEP ARRAY SEP IDENTIFIER:ID SQUARES INTEGER_LITERAL SQUAREC {: 
                                                                                        boolean existe = existeArrGlob(ID.toString(), "CHAR");
                                                                                        if (existe) {System.out.println("El array global -> " + ID.toString() + " <- ya fue declarado");}
                                                                                        scopePrograma.get(globalHash).add("Instancia GLOB ARR: " + ID.toString() + ":" + "CHAR"); 
                                                                                        RESULT = "INT";:};

//Declaracion de ARRAYS Y TODO LO RELACIONADO
arrayAsig ::= IDENTIFIER:ID EQ SQUARES elementos SQUAREC ENDEXPR {:
                                                                        String tipo = getTipo(ID.toString());
                                                                        boolean existe = existeArr(ID.toString(), tipo);
                                                                        boolean existe2 = existeArrGlob(ID.toString(), tipo);
                                                                        if (!existe && !existe2) {System.out.println("Este array -> " + ID.toString() + " <- no existe");}

                                                                        if (!todosIguales(elementosArray)) {System.out.println("Los elementos asignados deben coincidir en tipo entre ellos y de acuerdo al arreglo");}
                                                                        elementosArray.clear();:}
            | EQ SQUARES elementos:elem SQUAREC ENDEXPR {:RESULT = elem;:};

elementos ::= compAritOp:val1 COMA elementos:val2 {:String[] elementos1 = val1.toString().split(":");
                                                    elementosArray.add(elementos1[1]);:}
            | compAritOp:val1 {: 
                                String[] elementos1 = val1.toString().split(":");
                                elementosArray.add(elementos1[1]);; :};

arrayInsAsign ::= arrayIns:t1 arrayAsig:t2 {:
                                            if (!t1.equals(t2)) {System.out.println("ERROR ARRAY LOC -> No todos los valores coinciden con el tipo instanciado");}:};

arrayInsAsignGl ::= arrayInsGl:t1 arrayAsig:t2 {:
                                            if (!t1.equals(t2)) {System.out.println("ERROR ARRAY GLOB -> No todos los valores coinciden con el tipo instanciado");}:};

arrayElement ::= IDENTIFIER:ID SQUARES INTEGER_LITERAL:lit SQUAREC {: currentTemp++;
                                                                cod3D.append("\nt" + currentTemp + " = " + ID.toString() + ", " + lit);
                                                                String tipo = getTipo(ID.toString()); RESULT = "t" + currentTemp + ":" + tipo; :};


//Declaracion de switch
switchStruc ::= SWITCH PARENTS IDENTIFIER PARENTC DELIMETERBLOCK caseStruc DEFAULT SEP BLOCK DELIMETERBLOCK {:System.out.println("Se declaro estructura switch");:};
caseStruc ::= CASE SEP compAritOp SEP BLOCK caseStruc
            | CASE SEP compAritOp SEP BLOCK;


//Declaracion de FOR
forStruc ::= FOR SEP IDENTIFIER SEP IN SEP RANGE PARENTS exprP:expr1 COMA exprP:expr2 PARENTC DELIMETERBLOCK BLOCK DELIMETERBLOCK {: if(!expr1.equals("INT") || !expr2.equals("INT")) {System.out.println("ERROR SEMANTICO -> Los parametros del range deben ser de tipo entero");} :}
            | FOR SEP IDENTIFIER SEP IN SEP RANGE PARENTS exprP:expr1 PARENTC DELIMETERBLOCK BLOCK DELIMETERBLOCK {: if(!expr1.equals("INT")) {System.out.println("ERROR SEMANTICO -> Los parametros del range deben ser de tipo entero");} :}
            | FOR SEP IDENTIFIER SEP IN SEP RANGE PARENTS exprP:expr1 COMA exprP:expr2 COMA exprP:expr3 PARENTC DELIMETERBLOCK BLOCK DELIMETERBLOCK {: if(!expr1.equals("INT") || !expr2.equals("INT") || !expr3.equals("INT")) {System.out.println("ERROR SEMANTICO -> Los parametros del range deben ser de tipo entero");} :};


//Declaracion de parametros
paramStruc ::= PARAM SEP INT SEP IDENTIFIER:ID {:String tipo = getTipo(ID.toString()); RESULT = tipo; scopePrograma.get(currentHash).add("Instancia PARAM: " + ID.toString() + ":" + "INT"); :}
        | PARAM SEP CHAR SEP IDENTIFIER:ID {:String tipo = getTipo(ID.toString()); RESULT = tipo; scopePrograma.get(currentHash).add("Instancia PARAM: " + ID.toString() + ":" + "CHAR"); :}
        | PARAM SEP STRINGT SEP IDENTIFIER:ID {:String tipo = getTipo(ID.toString()); RESULT = tipo; scopePrograma.get(currentHash).add("Instancia PARAM: " + ID.toString() + ":" + "STRING"); :}
        | PARAM SEP FLOAT SEP IDENTIFIER:ID {:String tipo = getTipo(ID.toString()); RESULT = tipo; scopePrograma.get(currentHash).add("Instancia PARAM: " + ID.toString() + ":" + "FLOAT"); :}
        | PARAM SEP BOOL SEP IDENTIFIER:ID  {:String tipo = getTipo(ID.toString()); RESULT = tipo; scopePrograma.get(currentHash).add("Instancia PARAM: " + ID.toString() + ":" + "BOOL"); :}; 

paramList ::= paramStruc paramList
        | paramStruc;


printStruc ::= PRINT PARENTS numbers PARENTC
            | PRINT PARENTS IDENTIFIER PARENTC
            | PRINT PARENTS STRING_LITERAL PARENTC;


returnStruc ::=  RETURN:ss SEP exprP:val ENDEXPR {:
                                                boolean valido = validarReturn(val.toString()); 
                                                if (!valido) {System.out.println("ERROR RETORNO -> Tipo de retorno distinto al de la funcion");}:}
        | RETURN ENDEXPR;

//Manejo de errores

error ::= 
    error SEMI {: System.out.println("Error de sintaxis: se esperaba ; "); :}
    | error ENDEXPR {: System.out.println("Error de sintaxis: se esperaba ; "); :}
    | error SEP {: System.out.println("Error de sintaxis: se esperaba : "); :}
    | error IDENTIFIER {: System.out.println("Error de sintaxis: se esperaba un identificador "); :}
    | error PLUS {: System.out.println("Error de sintaxis: se esperaba + "); :}
    | error MINUSW {: System.out.println("Error de sintaxis: se esperaba - "); :}
    | error PRODUCT {: System.out.println("Error de sintaxis: se esperaba * "); :}
    | error DIVISION {: System.out.println("Error de sintaxis: se esperaba / "); :}
    | error POWER {: System.out.println("Error de sintaxis: se esperaba ^ "); :}
    | error MODULUS {: System.out.println("Error de sintaxis: se esperaba % "); :}
    | error STRINGT {: System.out.println("Error de sintaxis: se esperaba un string "); :}
    | error EQ {: System.out.println("Error de sintaxis: se esperaba = "); :}
    | error EQEQ {: System.out.println("Error de sintaxis: se esperaba == "); :}
    | error ABSTRACT {: System.out.println("Error de sintaxis: se esperaba una expresion abstracta "); :}
    | error BOOLEAN {: System.out.println("Error de sintaxis: se esperaba una expresion booleana "); :}
    | error INT {: System.out.println("Error de sintaxis: se esperaba int "); :}
    | error CHAR {: System.out.println("Error de sintaxis: se esperaba char "); :}
    | error FLOAT {: System.out.println("Error de sintaxis: se esperaba float "); :}
    | error BOOL {: System.out.println("Error de sintaxis: se esperaba bool "); :}
    | error BREAK {: System.out.println("Error de sintaxis: se esperaba break "); :}
    | error DOT {: System.out.println("Error de sintaxis: se esperaba . "); :}
    | error INTEGER_LITERAL {: System.out.println("Error de sintaxis: La expresion no corresponde con un numero "); :}
    | error FLOATNUM {: System.out.println("Error de sintaxis: La expresion debe ser un numero flotante "); :}
    | error TRUE {: System.out.println("Error de sintaxis: se esperaba true "); :}
    | error FALSE {: System.out.println("Error de sintaxis: se esperaba false "); :}
    | error DELIMETERBLOCK {: System.out.println("Error de sintaxis: se esperaba _ "); :}
    | error IF {: System.out.println("Error de sintaxis: se esperaba if "); :}
    | error ELSE {: System.out.println("Error de sintaxis: se esperaba else "); :}
    | error SWITCH {: System.out.println("Error de sintaxis: se esperaba switch "); :}
    | error CASE {: System.out.println("Error de sintaxis: se esperaba case "); :}
    | error FOR {: System.out.println("Error de sintaxis: se esperaba for "); :}
    | error WHILE {: System.out.println("Error de sintaxis: se esperaba while "); :}
    | error IN {: System.out.println("Error de sintaxis: se esperaba in "); :}
    | error RANGE {: System.out.println("Error de sintaxis: se esperaba range "); :}
    | error GRATHER {: System.out.println("Error de sintaxis: se esperaba > "); :}
    | error LOWER {: System.out.println("Error de sintaxis: se esperaba < "); :}
    | error GRATHERT {: System.out.println("Error de sintaxis: se esperaba >= "); :}
    | error LOWERT {: System.out.println("Error de sintaxis: se esperaba <= "); :}
    | error COMPARATION {: System.out.println("Error de sintaxis: se esperaba == "); :}
    | error DIFF {: System.out.println("Error de sintaxis: se esperaba != "); :}
    | error NEGATION {: System.out.println("Error de sintaxis: se esperaba ! "); :}
    | error AND {: System.out.println("Error de sintaxis: se esperaba && "); :}
    | error OR {: System.out.println("Error de sintaxis: se esperaba || "); :}
    | error FUNC {: System.out.println("Error de sintaxis: se esperaba func "); :}
    | error MAIN {: System.out.println("Error de sintaxis: se esperaba main "); :}
    | error PARAM {: System.out.println("Error de sintaxis: se esperaba un parametro "); :}
    | error PARENTS {: System.out.println("Error de sintaxis: se esperaba ( "); :}
    | error PARENTC {: System.out.println("Error de sintaxis: se esperaba ) "); :}
    | error SQUARES {: System.out.println("Error de sintaxis: se esperaba [ "); :}
    | error SQUAREC {: System.out.println("Error de sintaxis: se esperaba ] "); :}
    | error LOC {: System.out.println("Error de sintaxis: se esperaba loc "); :}
    | error GLOB {: System.out.println("Error de sintaxis: se esperaba glob "); :}
    | error RETURN {: System.out.println("Error de sintaxis: se esperaba return "); :}
    | error DEFAULT {: System.out.println("Error de sintaxis: se esperaba default "); :}
    | error BRAKE {: System.out.println("Error de sintaxis: se esperaba brake "); :}
    | error PRINT {: System.out.println("Error de sintaxis: se esperaba print "); :}
    | error INPUT {: System.out.println("Error de sintaxis: se esperaba input "); :};


